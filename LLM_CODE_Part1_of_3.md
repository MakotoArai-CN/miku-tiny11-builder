<!--
  Generated by LLM Code Printer
  Date: 2025-11-03T17:27:52.226Z
  Part: 1 of 3
  Files: 1-15
-->

# miku-tiny11-builder

## é¡¹ç›®ä¿¡æ¯

- **é¡¹ç›®åç§°**: miku-tiny11-builder
- **ç”Ÿæˆæ—¶é—´**: 2025/11/4 01:27:52
- **æ–‡ä»¶æ€»æ•°**: 43
- **å‹ç¼©æ¨¡å¼**: æ ‡å‡†å‹ç¼©

> âš ï¸ **æ³¨æ„**: ä»£ç å·²å‹ç¼©ï¼Œä½¿ç”¨æ—¶è¯·å…ˆæ ¼å¼åŒ–

## ç›®å½•ç»“æ„

```tree
..\miku-tiny11-builder\/
cmd/
  tiny11builder/
    main.go
  tiny11coremaker/
    main.go
  tiny11maker/
    main.go
internal/
  api/
    server.go
  app/
    builder.go
    core_builder.go
    interface.go
    nano_builder.go
  cli/
    admin.go
    args.go
  config/
    config.go
  image/
    manager.go
  logger/
    logger.go
  preinstall/
    manager.go
  registry/
    manager.go
    tweaks.go
  remover/
    apps.go
    core.go
    edge.go
    nano.go
  theme/
    applier.go
    manager.go
  types/
    errors.go
    types.go
  utils/
    console.go
    dism.go
    encoding.go
    filesystem.go
    pool.go
    process.go
    progress.go
log/
preinstall/
  installers/
  preinstall.json
resources/
  autounattend.xml
themes/
  miku/
    boot/
    images/
    sounds/
    wallpapers/
    autounattend.xml
    branding.json
    colors.json
    theme.json
.gitattributes
.gitignore
build.bat
go.mod
go.sum
README.md
```

## ä»£ç æ–‡ä»¶

### 1. cmd\tiny11builder\main.go

```go
package main
import (
"flag"
"fmt"
"os"
"path/filepath"
"runtime"
"strings"
"time"
"encoding/json"
"tiny11-builder/internal/api"
"tiny11-builder/internal/app"
"tiny11-builder/internal/cli"
"tiny11-builder/internal/config"
"tiny11-builder/internal/logger"
"tiny11-builder/internal/utils"
)
func main() {
if err := utils.InitConsole(); err != nil {
fmt.Printf("è­¦å‘Š: åˆå§‹åŒ–æ§åˆ¶å°å¤±è´¥: %v\n", err)
}
utils.SetConsoleTitle("Tiny11 Builder - Miku Edition ğŸ€")
apiMode := flag.Bool("api", false, "å¯åŠ¨APIæœåŠ¡å™¨æ¨¡å¼")
apiPort := flag.Int("port", 8080, "APIæœåŠ¡å™¨ç«¯å£")
iso := flag.String("iso", "", "ISOæŒ‚è½½çš„é©±åŠ¨å™¨å·")
mode := flag.String("mode", "", "æ„å»ºæ¨¡å¼: standard/core/nano")
themeName := flag.String("theme", "", "ä¸»é¢˜åç§°: default/miku")
helpFlag := flag.Bool("h", false, "æ˜¾ç¤ºå¸®åŠ©")
flag.Parse()
if *helpFlag {
showHelp()
return
}
if *apiMode {
runAPIMode(*apiPort)
return
}
if *iso != "" {
runCommandLineMode(*iso, *mode, *themeName)
return
}
runInteractiveMode()
}
func runCommandLineMode(isoDrive, buildMode, theme string) {
log := logger.NewLogger("tiny11builder-cli")
defer log.Close()
if !cli.IsAdmin() {
log.Error("éœ€è¦ç®¡ç†å‘˜æƒé™è¿è¡Œæ­¤ç¨‹åº")
os.Exit(1)
}
cfg := config.NewConfig()
cfg.ISODrive = strings.ToUpper(strings.TrimSuffix(isoDrive, ":")) + ":"
if err := cfg.EnsureDirectories(); err != nil {
log.Error("åˆ›å»ºå·¥ä½œç›®å½•å¤±è´¥: %v", err)
os.Exit(1)
}
if buildMode == "" {
log.Error("å¿…é¡»æŒ‡å®šæ„å»ºæ¨¡å¼: -mode standard|core|nano")
os.Exit(1)
}
if theme != "" && theme != "default" {
cfg.ThemeName = theme
}
runtime.GOMAXPROCS(runtime.NumCPU())
var builder app.Builder
switch buildMode {
case "standard":
cfg.CoreMode = false
builder = app.NewTiny11Builder(cfg, log)
case "core":
cfg.CoreMode = true
builder = app.NewTiny11CoreBuilder(cfg, log)
case "nano":
cfg.CoreMode = true
builder = app.NewTiny11NanoBuilder(cfg, log)
default:
log.Error("æ— æ•ˆçš„æ„å»ºæ¨¡å¼: %s", buildMode)
os.Exit(1)
}
log.Info("æ„å»ºæ¨¡å¼: %s", buildMode)
log.Info("ISOé©±åŠ¨å™¨: %s", cfg.ISODrive)
log.Info("ä¸»é¢˜: %s", cfg.ThemeName)
if err := builder.Build(); err != nil {
log.Error("æ„å»ºå¤±è´¥: %v", err)
os.Exit(1)
}
log.Success("æ„å»ºå®Œæˆï¼è¾“å‡ºæ–‡ä»¶: %s", builder.GetOutputISO())
}
func showHelp() {
fmt.Print(`
Tiny11 Builder - Miku Edition v2.1

ç”¨æ³•:
  # äº¤äº’å¼æ¨¡å¼
  tiny11builder.exe

  # å‘½ä»¤è¡Œæ¨¡å¼
  tiny11builder.exe -iso <drive> -mode <mode> [é€‰é¡¹]

  # APIæœåŠ¡å™¨æ¨¡å¼
  tiny11builder.exe -api [-port 8080]

å‚æ•°:
  -iso <drive>      ISOæŒ‚è½½çš„é©±åŠ¨å™¨å· (ä¾‹: H, E:)
  -mode <mode>      æ„å»ºæ¨¡å¼: standard, core, nano
  -theme <name>     ä¸»é¢˜åç§°: default, miku
  -h                æ˜¾ç¤ºæ­¤å¸®åŠ©
  -api              å¯åŠ¨APIæœåŠ¡å™¨
  -port <port>      APIæœåŠ¡å™¨ç«¯å£ (é»˜è®¤: 8080)

æ„å»ºæ¨¡å¼:
  standard          æ ‡å‡†ç‰ˆ (~5-6 GB, å¯æœåŠ¡)
  core              Coreç‰ˆ (~4-5 GB, ä¸å¯æœåŠ¡)
  nano              Nanoç‰ˆ (~2.5-3.5 GB, ç»ˆæç²¾ç®€)

ç¤ºä¾‹:
  # æ ‡å‡†ç‰ˆ + Mikuä¸»é¢˜
  tiny11builder.exe -iso H -mode standard -theme miku

  # Coreç‰ˆ
  tiny11builder.exe -iso H -mode core

  # Nanoç‰ˆ (ç»ˆæç²¾ç®€)
  tiny11builder.exe -iso H -mode nano -theme miku

  # APIæ¨¡å¼
  tiny11builder.exe -api
  curl -X POST http://localhost:8080/api/build \
    -d '{"isoDrive":"H:", "mode":"standard", "theme":"miku"}'
`)
}
func runInteractiveMode() {
showMainUI()
log := logger.NewLogger("tiny11builder")
defer log.Close()
if !cli.IsAdmin() {
log.Error("éœ€è¦ç®¡ç†å‘˜æƒé™è¿è¡Œæ­¤ç¨‹åº")
fmt.Println()
fmt.Println(utils.Colorize("è¯·ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œæ­¤ç¨‹åº:", utils.MikuYellow))
fmt.Println(utils.Colorize("  1. å³é”®ç‚¹å‡»ç¨‹åº", utils.MikuWhite))
fmt.Println(utils.Colorize("  2. é€‰æ‹©\"ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œ\"", utils.MikuWhite))
fmt.Println()
fmt.Print(utils.Colorize("æŒ‰Enteré”®é€€å‡º...", utils.MikuGray))
fmt.Scanln()
os.Exit(1)
}
prelimCfg := config.NewConfig()
buildDir := filepath.Join(prelimCfg.WorkDir, "build")
if utils.DirExists(buildDir) {
log.Warn("æ£€æµ‹åˆ°æ—§çš„æ„å»ºç›®å½•ï¼Œå°†è¿›è¡Œæ¸…ç†...")
spinner := utils.NewSpinner("æ­£åœ¨æ¸…ç†æ®‹ç•™æ–‡ä»¶...")
spinner.Start()
utils.RunCommand("dism", "/English", "/Unmount-Image", fmt.Sprintf("/MountDir:%s", prelimCfg.ScratchDir), "/Discard")
time.Sleep(1 * time.Second)
err := os.RemoveAll(buildDir)
spinner.Stop(err == nil)
if err != nil {
log.Error("æ¸…ç†æ—§ç›®å½•å¤±è´¥: %v", err)
log.Warn("è¯·æ‰‹åŠ¨åˆ é™¤ %s ç›®å½•æˆ–é‡å¯ç”µè„‘åå†è¯•ã€‚", buildDir)
fmt.Print(utils.Colorize("æŒ‰Enteré”®é€€å‡º...", utils.MikuGray))
fmt.Scanln()
os.Exit(1)
}
log.Success("æ¸…ç†å®Œæˆï¼")
fmt.Println()
}
cfg, buildMode, themeName, err := cli.ParseArgsUnified(os.Args[1:])
if err != nil {
log.Error("å‚æ•°è§£æé”™è¯¯: %v", err)
cli.PrintUsageUnified()
os.Exit(1)
}
if err := cfg.EnsureDirectories(); err != nil {
log.Error("åˆ›å»ºå·¥ä½œç›®å½•å¤±è´¥: %v", err)
os.Exit(1)
}
if buildMode == "" {
buildMode = showModeSelection()
}
if themeName != "" && themeName != "default" {
cfg.ThemeName = themeName
} else if themeName == "default" {
cfg.ThemeName = ""
} else {
if showThemeSelection() {
cfg.ThemeName = "miku"
} else {
cfg.ThemeName = ""
}
}
selectPreinstallApps(cfg, log)
runtime.GOMAXPROCS(runtime.NumCPU())
var builder app.Builder
switch buildMode {
case "standard":
cfg.CoreMode = false
builder = app.NewTiny11Builder(cfg, log)
case "core":
cfg.CoreMode = true
if !showCoreWarning() {
fmt.Println(utils.Colorize("\næ“ä½œå·²å–æ¶ˆã€‚", utils.MikuCyan))
os.Exit(0)
}
builder = app.NewTiny11CoreBuilder(cfg, log)
case "nano":
cfg.CoreMode = true
if !showNanoWarning() {
fmt.Println(utils.Colorize("\næ“ä½œå·²å–æ¶ˆã€‚", utils.MikuCyan))
os.Exit(0)
}
builder = app.NewTiny11NanoBuilder(cfg, log)
default:
log.Error("æ— æ•ˆçš„æ„å»ºæ¨¡å¼: %s", buildMode)
os.Exit(1)
}
log.Info("å·¥ä½œç›®å½•: %s", cfg.WorkDir)
log.Info("è¾“å‡ºè·¯å¾„: %s", cfg.OutputISO)
if err := builder.Build(); err != nil {
log.Error("æ„å»ºå¤±è´¥: %v", err)
fmt.Println()
fmt.Print(utils.Colorize("æŒ‰Enteré”®é€€å‡º...", utils.MikuGray))
fmt.Scanln()
os.Exit(1)
}
showSuccessInfo(builder, log)
}
func selectPreinstallApps(cfg *config.Config, log *logger.Logger) {
preinstallDir := filepath.Join(cfg.WorkDir, "preinstall")
configFile := filepath.Join(preinstallDir, "preinstall.json")
if !utils.FileExists(configFile) {
log.Info("æœªæ‰¾åˆ°é¢„è£…è½¯ä»¶é…ç½®æ–‡ä»¶ï¼Œè·³è¿‡é¢„è£…è½¯ä»¶åŠŸèƒ½")
return
}
data, err := os.ReadFile(configFile)
if err != nil {
log.Warn("è¯»å–é¢„è£…è½¯ä»¶é…ç½®å¤±è´¥: %vï¼Œè·³è¿‡é¢„è£…è½¯ä»¶åŠŸèƒ½", err)
return
}
var preinstallConfig struct {
Enabled bool `json:"enabled"`
Apps []struct {
ID string `json:"id"`
Name string `json:"name"`
Description string `json:"description"`
} `json:"apps"`
}
if err := json.Unmarshal(data, &preinstallConfig); err != nil {
log.Warn("è§£æé¢„è£…è½¯ä»¶é…ç½®å¤±è´¥: %vï¼Œè·³è¿‡é¢„è£…è½¯ä»¶åŠŸèƒ½", err)
return
}
if !preinstallConfig.Enabled {
log.Info("é¢„è£…è½¯ä»¶åŠŸèƒ½å·²ç¦ç”¨")
return
}
if len(preinstallConfig.Apps) == 0 {
log.Info("é¢„è£…è½¯ä»¶åˆ—è¡¨ä¸ºç©º")
return
}
fmt.Println()
fmt.Println(utils.Colorize("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”", utils.MikuCyan))
fmt.Println(utils.Colorize("â”‚                         è½¯ä»¶é¢„è£…é€‰é¡¹                                   â”‚", utils.MikuPink+utils.Bold))
fmt.Println(utils.Colorize("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜", utils.MikuCyan))
fmt.Println()
fmt.Println(utils.Colorize("  æ£€æµ‹åˆ°ä»¥ä¸‹å¯é¢„è£…è½¯ä»¶:", utils.MikuCyan))
fmt.Println()
for i, app := range preinstallConfig.Apps {
fmt.Printf(utils.Colorize("    [%d] %s", utils.MikuWhite), i+1, app.Name)
if app.Description != "" {
fmt.Printf(utils.Colorize(" - %s", utils.MikuGray), app.Description)
}
fmt.Println()
}
fmt.Println()
fmt.Println(utils.Colorize("  [A] å®‰è£…å…¨éƒ¨", utils.MikuGreen))
fmt.Println(utils.Colorize("  [N] ä¸å®‰è£…ä»»ä½•è½¯ä»¶ (æ¨è)", utils.MikuGray))
fmt.Println()
fmt.Print(utils.Colorize("è¯·é€‰æ‹© [ç¼–å·/A/N]: ", utils.MikuPink))
var choice string
fmt.Scanln(&choice)
choice = strings.TrimSpace(strings.ToUpper(choice))
switch choice {
case "A":
for _, app := range preinstallConfig.Apps {
cfg.PreinstallApps = append(cfg.PreinstallApps, app.ID)
}
fmt.Println(utils.Colorize("âœ“ å°†é¢„è£…å…¨éƒ¨è½¯ä»¶", utils.MikuGreen))
case "N", "":
fmt.Println(utils.Colorize("âœ“ ä¸é¢„è£…è½¯ä»¶", utils.MikuCyan))
default:
var idx int
if _, err := fmt.Sscanf(choice, "%d", &idx); err == nil {
if idx >= 1 && idx <= len(preinstallConfig.Apps) {
app := preinstallConfig.Apps[idx-1]
cfg.PreinstallApps = []string{app.ID}
fmt.Printf(utils.Colorize("âœ“ å°†é¢„è£…: %s\n", utils.MikuGreen), app.Name)
} else {
fmt.Println(utils.Colorize("âœ— æ— æ•ˆé€‰é¡¹ï¼Œä¸é¢„è£…è½¯ä»¶", utils.MikuRed))
}
} else {
fmt.Println(utils.Colorize("âœ— æ— æ•ˆé€‰é¡¹ï¼Œä¸é¢„è£…è½¯ä»¶", utils.MikuRed))
}
}
fmt.Println()
}
func showMainUI() {
utils.MikuBanner()
fmt.Println(utils.Colorize("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—", utils.MikuCyan))
fmt.Println(utils.Colorize("â•‘                    Windows 11 ç²¾ç®€é•œåƒæ„å»ºå·¥å…·                          â•‘", utils.MikuCyan))
fmt.Println(utils.Colorize("â•‘                         Miku Edition v2.1                              â•‘", utils.MikuPink))
fmt.Println(utils.Colorize("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", utils.MikuCyan))
fmt.Println()
}
func showModeSelection() string {
fmt.Println(utils.Colorize("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”", utils.MikuCyan))
fmt.Println(utils.Colorize("â”‚                         è¯·é€‰æ‹©æ„å»ºæ¨¡å¼                                 â”‚", utils.MikuPink+utils.Bold))
fmt.Println(utils.Colorize("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜", utils.MikuCyan))
fmt.Println()
fmt.Println(utils.Colorize("  [1] æ ‡å‡†ç‰ˆ (Standard)", utils.MikuCyan+utils.Bold))
fmt.Println(utils.Colorize("      â€¢ ç§»é™¤å¤§éƒ¨åˆ†é¢„è£…åº”ç”¨å’Œè†¨èƒ€è½¯ä»¶", utils.MikuWhite))
fmt.Println(utils.Colorize("      â€¢ ä¿ç•™ç³»ç»Ÿå¯æœåŠ¡æ€§", utils.MikuWhite))
fmt.Println(utils.Colorize("      â€¢ å¯å®‰è£…æ›´æ–°ã€è¯­è¨€åŒ…å’ŒåŠŸèƒ½", utils.MikuWhite))
fmt.Println(utils.Colorize("      â€¢ é€‚åˆæ—¥å¸¸ä½¿ç”¨", utils.MikuGreen))
fmt.Println(utils.Colorize("      â€¢ å¤§å°: ~5-6 GB", utils.MikuGray))
fmt.Println()
fmt.Println(utils.Colorize("  [2] Coreç‰ˆ (æé™ç²¾ç®€)", utils.MikuPink+utils.Bold))
fmt.Println(utils.Colorize("      â€¢ ç§»é™¤æ‰€æœ‰æ ‡å‡†ç‰ˆå†…å®¹", utils.MikuWhite))
fmt.Println(utils.Colorize("      â€¢ ç§»é™¤å¤§éƒ¨åˆ† WinSxS ç»„ä»¶", utils.MikuWhite))
fmt.Println(utils.Colorize("      â€¢ ç¦ç”¨ Windows Update å’Œ Defender", utils.MikuWhite))
fmt.Println(utils.Colorize("      â€¢ ä¸å¯æœåŠ¡ï¼Œä»…ç”¨äºæµ‹è¯•ç¯å¢ƒ", utils.MikuYellow))
fmt.Println(utils.Colorize("      â€¢ å¤§å°: ~4-5 GB", utils.MikuGray))
fmt.Println()
fmt.Println(utils.Colorize("  [3] Nanoç‰ˆ (ç»ˆæç²¾ç®€) âš¡", utils.MikuRed+utils.Bold))
fmt.Println(utils.Colorize("      â€¢ ç§»é™¤æ‰€æœ‰ Core ç‰ˆå†…å®¹", utils.MikuWhite))
fmt.Println(utils.Colorize("      â€¢ ç²¾ç®€é©±åŠ¨ã€å­—ä½“ã€ç³»ç»Ÿæ–‡ä»¶å¤¹", utils.MikuWhite))
fmt.Println(utils.Colorize("      â€¢ ç§»é™¤å¤§é‡ç³»ç»ŸæœåŠ¡", utils.MikuWhite))
fmt.Println(utils.Colorize("      â€¢ ä½¿ç”¨ ESD æ ¼å¼ (è¶…é«˜å‹ç¼©)", utils.MikuWhite))
fmt.Println(utils.Colorize("      â€¢ âš ï¸  æç«¯ç²¾ç®€ï¼Œä»…ç”¨äºç‰¹æ®Šåœºæ™¯", utils.MikuRed))
fmt.Println(utils.Colorize("      â€¢ å¤§å°: ~2.5-3.5 GB", utils.MikuGray))
fmt.Println()
fmt.Println(utils.Colorize("  [Q] é€€å‡ºç¨‹åº", utils.MikuGray))
fmt.Println()
for {
fmt.Print(utils.Colorize("è¯·è¾“å…¥é€‰é¡¹ [1/2/3/Q]: ", utils.MikuPink))
var choice string
fmt.Scanln(&choice)
choice = strings.ToUpper(strings.TrimSpace(choice))
switch choice {
case "1":
fmt.Println(utils.Colorize("âœ“ å·²é€‰æ‹©: æ ‡å‡†ç‰ˆ", utils.MikuGreen))
fmt.Println()
return "standard"
case "2":
fmt.Println(utils.Colorize("âœ“ å·²é€‰æ‹©: Coreç‰ˆ", utils.MikuPink))
fmt.Println()
return "core"
case "3":
fmt.Println(utils.Colorize("âœ“ å·²é€‰æ‹©: Nanoç‰ˆ (ç»ˆæç²¾ç®€)", utils.MikuRed))
fmt.Println()
return "nano"
case "Q", "QUIT", "EXIT":
fmt.Println(utils.Colorize("\nå†è§ï¼", utils.MikuCyan))
os.Exit(0)
default:
fmt.Println(utils.Colorize("  âœ— æ— æ•ˆé€‰é¡¹ï¼Œè¯·é‡æ–°è¾“å…¥", utils.MikuRed))
}
}
}
func showThemeSelection() bool {
fmt.Println(utils.Colorize("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”", utils.MikuCyan))
fmt.Println(utils.Colorize("â”‚                         ä¸»é¢˜é€‰æ‹©                                       â”‚", utils.MikuPink+utils.Bold))
fmt.Println(utils.Colorize("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜", utils.MikuCyan))
fmt.Println()
fmt.Println(utils.Colorize("  æ˜¯å¦åº”ç”¨ Miku ä¸»é¢˜?", utils.MikuCyan))
fmt.Println()
fmt.Println(utils.Colorize("  Mikuä¸»é¢˜åŒ…å«:", utils.MikuWhite))
fmt.Println(utils.Colorize("    â€¢ ç³»ç»Ÿåç§°æ˜¾ç¤ºä¸º 'Miku Tiny11'", utils.MikuWhite))
fmt.Println(utils.Colorize("    â€¢ é’è‰²å’Œç²‰è‰²é…è‰²æ–¹æ¡ˆ", utils.MikuWhite))
fmt.Println(utils.Colorize("    â€¢ ä¼˜åŒ–çš„è§†è§‰æ•ˆæœ", utils.MikuWhite))
fmt.Println(utils.Colorize("    â€¢ è‡ªå®šä¹‰å£çº¸å’Œå›¾æ ‡ (å¦‚æœå·²é…ç½®)", utils.MikuGray))
fmt.Println()
fmt.Print(utils.Colorize("åº”ç”¨Mikuä¸»é¢˜? [y/N]: ", utils.MikuPink))
var choice string
fmt.Scanln(&choice)
choice = strings.ToLower(strings.TrimSpace(choice))
apply := choice == "y" || choice == "yes"
if apply {
fmt.Println(utils.Colorize("âœ“ å°†åº”ç”¨Mikuä¸»é¢˜", utils.MikuGreen))
} else {
fmt.Println(utils.Colorize("âœ“ ä½¿ç”¨é»˜è®¤ä¸»é¢˜", utils.MikuCyan))
}
fmt.Println()
return apply
}
func showCoreWarning() bool {
fmt.Println(utils.Colorize("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—", utils.MikuRed))
fmt.Println(utils.Colorize("â•‘                           âš ï¸  é‡è¦è­¦å‘Š  âš ï¸                              â•‘", utils.MikuRed+utils.Bold))
fmt.Println(utils.Colorize("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£", utils.MikuRed))
fmt.Println(utils.Colorize("â•‘  Tiny11 Core æ˜¯ä¸€ä¸ªé«˜åº¦ç²¾ç®€çš„ç‰ˆæœ¬ï¼Œä»…ç”¨äºæµ‹è¯•å’Œå¼€å‘ç¯å¢ƒï¼             â•‘", utils.MikuYellow))
fmt.Println(utils.Colorize("â•‘  âš ï¸  ä¸å»ºè®®ç”¨äºæ—¥å¸¸ä½¿ç”¨ï¼ä»…é€‚åˆè™šæ‹Ÿæœºæµ‹è¯•ç¯å¢ƒï¼                        â•‘", utils.MikuRed+utils.Bold))
fmt.Println(utils.Colorize("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", utils.MikuRed))
fmt.Println()
fmt.Print(utils.Colorize("ç¡®è®¤ç»§ç»­? (yes/no): ", utils.MikuPink+utils.Bold))
var confirm string
fmt.Scanln(&confirm)
confirm = strings.ToLower(strings.TrimSpace(confirm))
return confirm == "yes" || confirm == "y"
}
func showNanoWarning() bool {
fmt.Println(utils.Colorize("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—", utils.MikuRed))
fmt.Println(utils.Colorize("â•‘                      âš ï¸  æç«¯ç²¾ç®€è­¦å‘Š  âš ï¸                               â•‘", utils.MikuRed+utils.Bold))
fmt.Println(utils.Colorize("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£", utils.MikuRed))
fmt.Println(utils.Colorize("â•‘  Tiny11 Nano æ˜¯ç»ˆæç²¾ç®€ç‰ˆæœ¬ï¼Œä»…ç”¨äºæç«¯æµ‹è¯•åœºæ™¯ï¼                     â•‘", utils.MikuYellow))
fmt.Println(utils.Colorize("â•‘                                                                        â•‘", utils.MikuYellow))
fmt.Println(utils.Colorize("â•‘  ç”Ÿæˆçš„é•œåƒå°†ï¼š                                                         â•‘", utils.MikuYellow))
fmt.Println(utils.Colorize("â•‘    â€¢ ç§»é™¤å‡ ä¹æ‰€æœ‰å¯ç§»é™¤çš„ç³»ç»Ÿç»„ä»¶                                       â•‘", utils.MikuWhite))
fmt.Println(utils.Colorize("â•‘    â€¢ ç²¾ç®€é©±åŠ¨ã€å­—ä½“ã€ç³»ç»Ÿæ–‡ä»¶å¤¹                                         â•‘", utils.MikuWhite))
fmt.Println(utils.Colorize("â•‘    â€¢ ç§»é™¤å¤§é‡ç³»ç»ŸæœåŠ¡ï¼ˆæ‰“å°ã€è“ç‰™ã€è¯Šæ–­ç­‰ï¼‰                             â•‘", utils.MikuWhite))
fmt.Println(utils.Colorize("â•‘    â€¢ å®Œå…¨ç¦ç”¨ Windows Update å’Œ Defender                                â•‘", utils.MikuWhite))
fmt.Println(utils.Colorize("â•‘    â€¢ ä½¿ç”¨ ESD æ ¼å¼å¯¼å‡ºï¼ˆè¶…é«˜å‹ç¼©ä½†è§£å‹æ…¢ï¼‰                              â•‘", utils.MikuWhite))
fmt.Println(utils.Colorize("â•‘    â€¢ å¯èƒ½å¯¼è‡´æŸäº›è½¯ä»¶æ— æ³•è¿è¡Œ                                           â•‘", utils.MikuWhite))
fmt.Println(utils.Colorize("â•‘                                                                        â•‘", utils.MikuYellow))
fmt.Println(utils.Colorize("â•‘  âš ï¸  æ­¤ç‰ˆæœ¬å¯èƒ½æ— æ³•æ­£å¸¸å¯åŠ¨ï¼ä»…ç”¨äºå®éªŒå’Œç‰¹æ®Šåœºæ™¯ï¼                    â•‘", utils.MikuRed+utils.Bold))
fmt.Println(utils.Colorize("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", utils.MikuRed))
fmt.Println()
fmt.Print(utils.Colorize("ç¡®è®¤ç»§ç»­? è¯·è¾“å…¥ 'I UNDERSTAND' (å¤§å†™): ", utils.MikuPink+utils.Bold))
var confirm string
fmt.Scanln(&confirm)
return confirm == "I UNDERSTAND"
}
func showSuccessInfo(builder app.Builder, log *logger.Logger) {
fmt.Println()
log.Header("âœ¨ æ„å»ºå®Œæˆ âœ¨")
log.Success("Tiny11é•œåƒå·²æˆåŠŸåˆ›å»º!")
isoPath := builder.GetOutputISO()
isoInfo, err := os.Stat(isoPath)
if err == nil {
fmt.Println()
fmt.Println(utils.Colorize("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—", utils.MikuCyan))
fmt.Println(utils.Colorize("â•‘                          ğŸ“Š æ„å»ºç»Ÿè®¡                                   â•‘", utils.MikuCyan+utils.Bold))
fmt.Println(utils.Colorize("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", utils.MikuCyan))
fmt.Println()
fmt.Printf("  %s %s\n", utils.Colorize("ISOå¤§å°:    ", utils.MikuCyan), utils.Colorize(utils.FormatBytes(isoInfo.Size()), utils.MikuGreen+utils.Bold))
fmt.Printf("  %s %s\n", utils.Colorize("è¾“å‡ºè·¯å¾„:   ", utils.MikuCyan), utils.Colorize(isoPath, utils.MikuWhite))
fmt.Printf("  %s %s\n", utils.Colorize("åˆ›å»ºæ—¶é—´:   ", utils.MikuCyan), utils.Colorize(isoInfo.ModTime().Format("2006-01-02 15:04:05"), utils.MikuGray))
}
fmt.Println()
fmt.Println(utils.Colorize("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—", utils.MikuPink))
fmt.Println(utils.Colorize("â•‘              â™ªâ”(ãƒ»oï½¥)â”›â™ªâ”— ( ï½¥oï½¥) â”“â™ª                                   â•‘", utils.MikuPink+utils.Bold))
fmt.Println(utils.Colorize("â•‘                æ„Ÿè°¢ä½¿ç”¨ Miku Tiny11 Builder!                           â•‘", utils.MikuCyan))
fmt.Println(utils.Colorize("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", utils.MikuPink))
fmt.Println()
fmt.Print(utils.Colorize("æŒ‰Enteré”®é€€å‡º...", utils.MikuGray))
fmt.Scanln()
}
```

### 2. cmd\tiny11coremaker\main.go

```go
package main
import (
"fmt"
"os"
"tiny11-builder/internal/app"
"tiny11-builder/internal/cli"
"tiny11-builder/internal/logger"
"tiny11-builder/internal/utils"
)
func main() {
if err := utils.InitConsole(); err != nil {
fmt.Printf("è­¦å‘Š: åˆå§‹åŒ–æ§åˆ¶å°å¤±è´¥: %v\n", err)
}
utils.SetConsoleTitle("Tiny11 Core Builder - Miku Edition ğŸ€")
utils.MikuBanner()
fmt.Println()
fmt.Println(utils.Colorize("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—", utils.MikuRed))
fmt.Println(utils.Colorize("â•‘                           âš ï¸  é‡è¦è­¦å‘Š  âš ï¸                              â•‘", utils.MikuRed))
fmt.Println(utils.Colorize("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£", utils.MikuRed))
fmt.Println(utils.Colorize("â•‘  Tiny11 Core æ˜¯ä¸€ä¸ªé«˜åº¦ç²¾ç®€çš„ç‰ˆæœ¬ï¼Œä»…ç”¨äºæµ‹è¯•å’Œå¼€å‘ç¯å¢ƒï¼             â•‘", utils.MikuYellow))
fmt.Println(utils.Colorize("â•‘                                                                        â•‘", utils.MikuYellow))
fmt.Println(utils.Colorize("â•‘  ç”Ÿæˆçš„é•œåƒå°†ï¼š                                                         â•‘", utils.MikuYellow))
fmt.Println(utils.Colorize("â•‘    â€¢ ç§»é™¤å¤§éƒ¨åˆ†ç³»ç»Ÿç»„ä»¶                                                 â•‘", utils.MikuWhite))
fmt.Println(utils.Colorize("â•‘    â€¢ æ— æ³•å®‰è£…Windowsæ›´æ–°                                                â•‘", utils.MikuWhite))
fmt.Println(utils.Colorize("â•‘    â€¢ æ— æ³•æ·»åŠ è¯­è¨€åŒ…å’ŒåŠŸèƒ½                                               â•‘", utils.MikuWhite))
fmt.Println(utils.Colorize("â•‘    â€¢ ç¦ç”¨Windows Defenderå’Œç³»ç»Ÿæ¢å¤                                     â•‘", utils.MikuWhite))
fmt.Println(utils.Colorize("â•‘                                                                        â•‘", utils.MikuYellow))
fmt.Println(utils.Colorize("â•‘  âš ï¸  ä¸å»ºè®®ç”¨äºæ—¥å¸¸ä½¿ç”¨ï¼ä»…é€‚åˆè™šæ‹Ÿæœºæµ‹è¯•ç¯å¢ƒï¼                        â•‘", utils.MikuRed+utils.Bold))
fmt.Println(utils.Colorize("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", utils.MikuRed))
fmt.Println()
fmt.Print(utils.Colorize("æ˜¯å¦ç»§ç»­? (yes/no): ", utils.MikuPink))
var confirm string
fmt.Scanln(&confirm)
if confirm != "yes" && confirm != "YES" && confirm != "y" && confirm != "Y" {
fmt.Println(utils.Colorize("\næ“ä½œå·²å–æ¶ˆã€‚", utils.MikuCyan))
os.Exit(0)
}
fmt.Println()
log := logger.NewLogger("tiny11coremaker")
defer log.Close()
if !cli.IsAdmin() {
log.Error("éœ€è¦ç®¡ç†å‘˜æƒé™è¿è¡Œæ­¤ç¨‹åº")
fmt.Println()
fmt.Println(utils.Colorize("è¯·ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œæ­¤ç¨‹åº:", utils.MikuYellow))
fmt.Println(utils.Colorize("  1. å³é”®ç‚¹å‡»ç¨‹åº", utils.MikuWhite))
fmt.Println(utils.Colorize("  2. é€‰æ‹©\"ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œ\"", utils.MikuWhite))
fmt.Println()
fmt.Print(utils.Colorize("æŒ‰Enteré”®é€€å‡º...", utils.MikuGray))
fmt.Scanln()
os.Exit(1)
}
config, err := cli.ParseArgs(os.Args[1:])
if err != nil {
log.Error("å‚æ•°è§£æé”™è¯¯: %v", err)
cli.PrintUsage()
os.Exit(1)
}
config.CoreMode = true
builder := app.NewTiny11CoreBuilder(config, log)
if err := builder.Build(); err != nil {
log.Error("æ„å»ºå¤±è´¥: %v", err)
fmt.Println()
fmt.Print(utils.Colorize("æŒ‰Enteré”®é€€å‡º...", utils.MikuGray))
fmt.Scanln()
os.Exit(1)
}
fmt.Println()
log.Header("âœ¨ Coreç‰ˆæœ¬æ„å»ºå®Œæˆ âœ¨")
log.Success("Tiny11 Coreé•œåƒå·²æˆåŠŸåˆ›å»º!")
log.Info("è¾“å‡ºæ–‡ä»¶: %s", utils.Colorize(builder.GetOutputISO(), utils.MikuCyan))
fmt.Println()
fmt.Println(utils.Colorize("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—", utils.MikuYellow))
fmt.Println(utils.Colorize("â•‘  âš ï¸  ä½¿ç”¨æé†’:                                                          â•‘", utils.MikuYellow))
fmt.Println(utils.Colorize("â•‘    â€¢ æ­¤é•œåƒä¸å¯æœåŠ¡ï¼Œæ— æ³•æ¥æ”¶æ›´æ–°                                       â•‘", utils.MikuWhite))
fmt.Println(utils.Colorize("â•‘    â€¢ ä»…å»ºè®®åœ¨éš”ç¦»çš„æµ‹è¯•ç¯å¢ƒä¸­ä½¿ç”¨                                       â•‘", utils.MikuWhite))
fmt.Println(utils.Colorize("â•‘    â€¢ ä¸è¦ç”¨äºç”Ÿäº§ç¯å¢ƒæˆ–æ—¥å¸¸ä½¿ç”¨                                         â•‘", utils.MikuWhite))
fmt.Println(utils.Colorize("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", utils.MikuYellow))
fmt.Println()
fmt.Println(utils.Colorize("        â™ªâ”(ãƒ»oï½¥)â”›â™ªâ”— ( ï½¥oï½¥) â”“â™ª", utils.MikuPink))
fmt.Println(utils.Colorize("          æ„Ÿè°¢ä½¿ç”¨ Miku Tiny11 Core!", utils.MikuCyan))
fmt.Println()
fmt.Print(utils.Colorize("æŒ‰Enteré”®é€€å‡º...", utils.MikuGray))
fmt.Scanln()
}
```

### 3. cmd\tiny11maker\main.go

```go
package main
import (
"fmt"
"os"
"tiny11-builder/internal/app"
"tiny11-builder/internal/cli"
"tiny11-builder/internal/logger"
"tiny11-builder/internal/utils"
)
func main() {
if err := utils.InitConsole(); err != nil {
fmt.Printf("è­¦å‘Š: åˆå§‹åŒ–æ§åˆ¶å°å¤±è´¥: %v\n", err)
}
utils.SetConsoleTitle("Tiny11 Builder - Miku Edition ğŸ€")
utils.MikuBanner()
log := logger.NewLogger("tiny11maker")
defer log.Close()
if !cli.IsAdmin() {
log.Error("éœ€è¦ç®¡ç†å‘˜æƒé™è¿è¡Œæ­¤ç¨‹åº")
fmt.Println()
fmt.Println(utils.Colorize("è¯·ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œæ­¤ç¨‹åº:", utils.MikuYellow))
fmt.Println(utils.Colorize("  1. å³é”®ç‚¹å‡»ç¨‹åº", utils.MikuWhite))
fmt.Println(utils.Colorize("  2. é€‰æ‹©\"ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œ\"", utils.MikuWhite))
fmt.Println()
fmt.Print(utils.Colorize("æŒ‰Enteré”®é€€å‡º...", utils.MikuGray))
fmt.Scanln()
os.Exit(1)
}
config, err := cli.ParseArgs(os.Args[1:])
if err != nil {
log.Error("å‚æ•°è§£æé”™è¯¯: %v", err)
cli.PrintUsage()
os.Exit(1)
}
builder := app.NewTiny11Builder(config, log)
if err := builder.Build(); err != nil {
log.Error("æ„å»ºå¤±è´¥: %v", err)
fmt.Println()
fmt.Print(utils.Colorize("æŒ‰Enteré”®é€€å‡º...", utils.MikuGray))
fmt.Scanln()
os.Exit(1)
}
fmt.Println()
log.Header("âœ¨ æ„å»ºå®Œæˆ âœ¨")
log.Success("Tiny11é•œåƒå·²æˆåŠŸåˆ›å»º!")
log.Info("è¾“å‡ºæ–‡ä»¶: %s", utils.Colorize(builder.GetOutputISO(), utils.MikuCyan))
fmt.Println()
fmt.Println(utils.Colorize("        â™ªâ”(ãƒ»oï½¥)â”›â™ªâ”— ( ï½¥oï½¥) â”“â™ª", utils.MikuPink))
fmt.Println(utils.Colorize("          æ„Ÿè°¢ä½¿ç”¨ Miku Tiny11!", utils.MikuCyan))
fmt.Println()
fmt.Print(utils.Colorize("æŒ‰Enteré”®é€€å‡º...", utils.MikuGray))
fmt.Scanln()
}
```

### 4. internal\api\server.go

```go
package api
import (
"encoding/json"
"fmt"
"net/http"
"sync"
"tiny11-builder/internal/app"
"tiny11-builder/internal/config"
"tiny11-builder/internal/logger"
"tiny11-builder/internal/types"
)
type Server struct {
port int
log *logger.Logger
mu sync.RWMutex
status *types.BuildStatus
}
func NewServer(port int, log *logger.Logger) *Server {
return &Server{
port: port, log: log, status: &types.BuildStatus{
Phase: "idle", Progress: 0}}
}
func (s *Server) Start() error {
http.HandleFunc("/api/build", s.handleBuild)
http.HandleFunc("/api/status", s.handleStatus)
http.HandleFunc("/api/themes", s.handleThemes)
http.HandleFunc("/api/preinstall", s.handlePreinstall)
addr := fmt.Sprintf(":%d", s.port)
s.log.Info("APIæœåŠ¡å™¨å¯åŠ¨åœ¨ http://localhost%s", addr)
return http.ListenAndServe(addr, nil)
}
func (s *Server) handleBuild(w http.ResponseWriter, r *http.Request) {
if r.Method != http.MethodPost {
http.Error(w, "ä»…æ”¯æŒ POST", http.StatusMethodNotAllowed)
return
}
var req types.BuildRequest
if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
s.sendError(w, "æ— æ•ˆçš„è¯·æ±‚", err)
return
}
go s.executeBuild(&req)
s.sendJSON(w, types.BuildResponse{
Success: true, Message: "æ„å»ºå·²å¯åŠ¨"})
}
func (s *Server) executeBuild(req *types.BuildRequest) {
s.updateStatus("preparing", 0, "å‡†å¤‡æ„å»ºç¯å¢ƒ")
cfg := config.NewConfig()
cfg.ISODrive = req.ISODrive
cfg.ThemeName = req.Theme
cfg.PreinstallApps = req.PreinstallApps
cfg.ImageIndex = req.ImageIndex
if req.ScratchDrive != "" {
cfg.ScratchDrive = req.ScratchDrive
}
log := logger.NewLogger("api-build")
defer log.Close()
var builder app.Builder
if req.Mode == types.ModeCore {
cfg.CoreMode = true
builder = app.NewTiny11CoreBuilder(cfg, log)
} else {
builder = app.NewTiny11Builder(cfg, log)
}
s.updateStatus("building", 10, "å¼€å§‹æ„å»º")
if err := builder.Build(); err != nil {
s.updateStatus("error", 0, err.Error())
return
}
s.updateStatus("complete", 100, "æ„å»ºå®Œæˆ")
s.mu.Lock()
s.status.OutputISO = builder.GetOutputISO()
s.mu.Unlock()
}
func (s *Server) handleStatus(w http.ResponseWriter, r *http.Request) {
s.mu.RLock()
defer s.mu.RUnlock()
s.sendJSON(w, s.status)
}
func (s *Server) handleThemes(w http.ResponseWriter, r *http.Request) {
themes := []string{"default", "miku"}
s.sendJSON(w, themes)
}
func (s *Server) handlePreinstall(w http.ResponseWriter, r *http.Request) {
apps := []map[string]string{{"id": "chrome", "name": "Google Chrome"}, {"id": "7zip", "name": "7-Zip"}}
s.sendJSON(w, apps)
}
func (s *Server) updateStatus(phase string, progress float64, message string) {
s.mu.Lock()
defer s.mu.Unlock()
s.status.Phase = phase
s.status.Progress = progress
s.status.Message = message
s.status.IsComplete = phase == "complete"
if phase == "error" {
s.status.Error = message
}
}
func (s *Server) sendJSON(w http.ResponseWriter, data interface{}) {
w.Header().Set("Content-Type", "application/json")
json.NewEncoder(w).Encode(data)
}
func (s *Server) sendError(w http.ResponseWriter, message string, err error) {
w.WriteHeader(http.StatusBadRequest)
s.sendJSON(w, types.BuildResponse{
Success: false, Message: message, Error: err.Error()})
}
```

### 5. internal\app\builder.go

```go
package app
import (
"fmt"
"path/filepath"
"tiny11-builder/internal/config"
"tiny11-builder/internal/image"
"tiny11-builder/internal/logger"
"tiny11-builder/internal/registry"
"tiny11-builder/internal/remover"
"tiny11-builder/internal/theme"
"tiny11-builder/internal/utils"
)
type Tiny11Builder struct {
config *config.Config
log *logger.Logger
imgMgr *image.Manager
regMgr *registry.Manager
remover *remover.AppRemover
themeMgr *theme.Manager
themeApplier *theme.Applier
outputISO string
}
func NewTiny11Builder(cfg *config.Config, log *logger.Logger) *Tiny11Builder {
themeMgr := theme.NewManager(cfg, log)
builder := &Tiny11Builder{
config: cfg, log: log, imgMgr: image.NewManager(cfg, log), regMgr: registry.NewManager(cfg, log), remover: remover.NewAppRemover(cfg, log), themeMgr: themeMgr, }
builder.themeApplier = theme.NewApplier(cfg, log, themeMgr)
return builder
}
func (b *Tiny11Builder) Build() error {
b.log.Header("Tiny11 Builder - æ ‡å‡†ç‰ˆ")
var imageUnmounted = false
if err := b.executeBasicSteps(); err != nil {
return err
}
b.log.Step(3, "è·å–é•œåƒä¿¡æ¯")
imageInfo, err := b.imgMgr.GetImageInfo()
if err != nil {
return fmt.Errorf("è·å–é•œåƒä¿¡æ¯å¤±è´¥: %w", err)
}
b.log.Info("æ¶æ„: %s, è¯­è¨€: %s, ç´¢å¼•: %d", imageInfo.Architecture, imageInfo.Language, imageInfo.Index)
b.log.Step(4, "æŒ‚è½½install.wim")
if err := b.imgMgr.MountInstallWim(imageInfo.Index); err != nil {
return fmt.Errorf("æŒ‚è½½å¤±è´¥: %w", err)
}
defer func() {
if !imageUnmounted {
b.log.Info("æ‰§è¡Œç´§æ€¥æ¸…ç†...")
b.regMgr.UnloadHives()
b.imgMgr.UnmountImage(false)
}
}()
if err := b.executeRemovalSteps(); err != nil {
return err
}
b.log.Step(7, "åº”ç”¨æ³¨å†Œè¡¨ä¼˜åŒ–")
if err := b.regMgr.LoadHives(); err != nil {
return fmt.Errorf("åŠ è½½æ³¨å†Œè¡¨å¤±è´¥: %w", err)
}
if err := b.regMgr.ApplyTweaks(); err != nil {
b.log.Warn("åº”ç”¨ä¼˜åŒ–å¤±è´¥: %v", err)
}
if b.config.ThemeName != "" {
b.log.Step(8, "åº”ç”¨è‡ªå®šä¹‰ä¸»é¢˜: "+b.config.ThemeName)
if err := b.applyTheme(imageInfo.Name); err != nil {
b.log.Warn("ä¸»é¢˜åº”ç”¨å¤±è´¥: %v", err)
}
} else {
b.log.Step(8, "è·³è¿‡ä¸»é¢˜è‡ªå®šä¹‰ (æœªæŒ‡å®šä¸»é¢˜)")
}
b.log.Info("å¸è½½æ³¨å†Œè¡¨Hive...")
if err := b.regMgr.UnloadHives(); err != nil {
b.log.Warn("å¸è½½æ³¨å†Œè¡¨å¤±è´¥: %v", err)
}
b.copyAutounattend()
if err := b.executeFinalSteps(imageInfo); err != nil {
return err
}
imageUnmounted = true
return nil
}
func (b *Tiny11Builder) applyTheme(originalEditionName string) error {
themePath := filepath.Join(b.config.ThemesDir, b.config.ThemeName)
if !utils.DirExists(themePath) {
return fmt.Errorf("ä¸»é¢˜ç›®å½•ä¸å­˜åœ¨: %s", themePath)
}
themeFile := filepath.Join(themePath, "theme.json")
if !utils.FileExists(themeFile) {
return fmt.Errorf("ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: %s", themeFile)
}
activeTheme, err := b.themeMgr.LoadTheme(b.config.ThemeName)
if err != nil {
return fmt.Errorf("åŠ è½½ä¸»é¢˜å¤±è´¥: %w", err)
}
warnings := b.themeMgr.ValidateTheme(activeTheme)
if len(warnings) > 0 {
b.log.Warn("ä¸»é¢˜éªŒè¯è­¦å‘Š:")
for _, warn := range warnings {
b.log.Warn("  â€¢ %s", warn)
}
}
if err := b.themeApplier.ApplyTheme(activeTheme); err != nil {
return err
}
return nil
}
func (b *Tiny11Builder) executeBasicSteps() error {
b.log.Step(1, "éªŒè¯ISOé•œåƒ")
if err := b.imgMgr.ValidateISO(); err != nil {
return fmt.Errorf("ISOéªŒè¯å¤±è´¥: %w", err)
}
b.log.Step(2, "å¤åˆ¶Windowsé•œåƒæ–‡ä»¶")
if err := b.imgMgr.CopyImageFiles(); err != nil {
return fmt.Errorf("å¤åˆ¶æ–‡ä»¶å¤±è´¥: %w", err)
}
return nil
}
func (b *Tiny11Builder) executeRemovalSteps() error {
b.log.Step(5, "ç§»é™¤é¢„è£…åº”ç”¨")
if err := b.remover.RemoveProvisionedApps(); err != nil {
return fmt.Errorf("ç§»é™¤åº”ç”¨å¤±è´¥: %w", err)
}
b.log.Step(6, "ç§»é™¤Edgeå’ŒOneDrive")
if err := b.remover.RemoveEdge(); err != nil {
b.log.Warn("ç§»é™¤Edgeå¤±è´¥: %v", err)
}
if err := b.remover.RemoveOneDrive(); err != nil {
b.log.Warn("ç§»é™¤OneDriveå¤±è´¥: %v", err)
}
if err := b.remover.RemoveScheduledTasks(); err != nil {
b.log.Warn("ç§»é™¤è®¡åˆ’ä»»åŠ¡å¤±è´¥: %v", err)
}
return nil
}
func (b *Tiny11Builder) executeFinalSteps(imageInfo *image.ImageInfo) error {
b.log.Step(9, "æ¸…ç†å’Œä¼˜åŒ–é•œåƒ")
if err := b.imgMgr.CleanupImage(); err != nil {
b.log.Warn("æ¸…ç†é•œåƒå¤±è´¥ï¼ˆè·³è¿‡ï¼‰: %v", err)
}
b.log.Step(10, "å¯¼å‡ºä¼˜åŒ–åçš„é•œåƒ")
if err := b.imgMgr.UnmountImage(true); err != nil {
return fmt.Errorf("å¸è½½å¤±è´¥: %w", err)
}
if err := b.imgMgr.ExportImage(imageInfo.Index); err != nil {
return fmt.Errorf("å¯¼å‡ºå¤±è´¥: %w", err)
}
b.log.Step(11, "å¤„ç†boot.wim")
if err := b.processBootWim(); err != nil {
return fmt.Errorf("å¤„ç†boot.wimå¤±è´¥: %w", err)
}
b.log.Step(12, "åˆ›å»ºISOé•œåƒ")
isoPath, err := b.imgMgr.CreateISO()
if err != nil {
return fmt.Errorf("åˆ›å»ºISOå¤±è´¥: %w", err)
}
b.outputISO = isoPath
b.log.Step(13, "æ¸…ç†ä¸´æ—¶æ–‡ä»¶")
if err := b.imgMgr.Cleanup(); err != nil {
b.log.Warn("æ¸…ç†ä¸´æ—¶æ–‡ä»¶å¤±è´¥: %v", err)
}
return nil
}
func (b *Tiny11Builder) copyAutounattend() error {
b.log.Info("å¤åˆ¶è‡ªåŠ¨åº”ç­”æ–‡ä»¶...")
autoUnattendSrc := filepath.Join(b.config.ResourcesDir, "autounattend.xml")
autoUnattendDst := filepath.Join(b.config.ScratchDir, "Windows", "System32", "Sysprep", "autounattend.xml")
if !utils.FileExists(autoUnattendSrc) {
b.log.Warn("autounattend.xml ä¸å­˜åœ¨: %s", autoUnattendSrc)
b.log.Info("å°è¯•ä»ä¸»é¢˜æˆ–é»˜è®¤ä½ç½®è·å–...")
if b.config.ThemeName != "default" && b.config.ThemeName != "" {
themePath := filepath.Join(b.config.WorkDir, "themes", b.config.ThemeName, "autounattend.xml")
if utils.FileExists(themePath) {
autoUnattendSrc = themePath
b.log.Success("ä½¿ç”¨ä¸»é¢˜ä¸­çš„autounattend.xml")
}
}
if !utils.FileExists(autoUnattendSrc) {
b.log.Info("åˆ›å»ºé»˜è®¤çš„autounattend.xml...")
if err := b.createDefaultAutounattend(autoUnattendSrc); err != nil {
return fmt.Errorf("åˆ›å»ºé»˜è®¤autounattend.xmlå¤±è´¥: %w", err)
}
}
}
dstDir := filepath.Dir(autoUnattendDst)
if err := utils.EnsureDir(dstDir); err != nil {
return fmt.Errorf("åˆ›å»ºç›®æ ‡ç›®å½•å¤±è´¥: %w", err)
}
if err := utils.CopyFile(autoUnattendSrc, autoUnattendDst); err != nil {
return fmt.Errorf("å¤åˆ¶autounattend.xmlå¤±è´¥: %w", err)
}
b.log.Success("autounattend.xml å¤åˆ¶æˆåŠŸ")
isoAutounattend := filepath.Join(b.config.Tiny11Dir, "autounattend.xml")
if err := utils.CopyFile(autoUnattendSrc, isoAutounattend); err != nil {
b.log.Warn("å¤åˆ¶autounattend.xmlåˆ°ISOæ ¹ç›®å½•å¤±è´¥: %v", err)
} else {
b.log.Info("å·²å¤åˆ¶åˆ°ISOæ ¹ç›®å½•")
}
return nil
}
func (b *Tiny11Builder) createDefaultAutounattend(path string) error {
defaultContent := `<?xml version="1.0" encoding="utf-8"?>
<unattend xmlns="urn:schemas-microsoft-com:unattend">
    <settings pass="oobeSystem">
        <component xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" 
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
                   name="Microsoft-Windows-Shell-Setup" 
                   processorArchitecture="amd64" 
                   publicKeyToken="31bf3856ad364e35" 
                   language="neutral" 
                   versionScope="nonSxS">
            <OOBE>
                <HideEULAPage>true</HideEULAPage>
                <HideOEMRegistrationScreen>true</HideOEMRegistrationScreen>
                <HideOnlineAccountScreens>true</HideOnlineAccountScreens>
                <HideWirelessSetupInOOBE>false</HideWirelessSetupInOOBE>
                <ProtectYourPC>3</ProtectYourPC>
                <SkipUserOOBE>false</SkipUserOOBE>
                <SkipMachineOOBE>false</SkipMachineOOBE>
            </OOBE>
            <UserAccounts>
                <LocalAccounts>
                    <LocalAccount wcm:action="add">
                        <Password>
                            <Value></Value>
                            <PlainText>true</PlainText>
                        </Password>
                        <Description>Local Administrator</Description>
                        <DisplayName>Admin</DisplayName>
                        <Group>Administrators</Group>
                        <Name>Admin</Name>
                    </LocalAccount>
                </LocalAccounts>
            </UserAccounts>
        </component>
    </settings>
    <settings pass="windowsPE">
        <component xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" 
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
                   name="Microsoft-Windows-Setup" 
                   processorArchitecture="amd64" 
                   publicKeyToken="31bf3856ad364e35" 
                   language="neutral" 
                   versionScope="nonSxS">
            <DynamicUpdate>
                <Enable>false</Enable>
                <WillShowUI>OnError</WillShowUI>
            </DynamicUpdate>
            <ImageInstall>
                <OSImage>
                    <Compact>true</Compact>
                    <WillShowUI>OnError</WillShowUI>
                    <InstallFrom>
                        <MetaData wcm:action="add">
                            <Key>/IMAGE/INDEX</Key>
                            <Value>1</Value>
                        </MetaData>
                    </InstallFrom>
                </OSImage>
            </ImageInstall>
            <UserData>
                <ProductKey>
                    <Key></Key>
                </ProductKey>
                <AcceptEula>true</AcceptEula>
            </UserData>
        </component>
    </settings>
</unattend>`
if err := utils.EnsureDir(filepath.Dir(path)); err != nil {
return err
}
return utils.WriteFile(path, []byte(defaultContent))
}
func (b *Tiny11Builder) processBootWim() error {
var bootUnmounted = false
if err := b.imgMgr.MountBootWim(); err != nil {
return err
}
defer func() {
if !bootUnmounted {
b.log.Info("æ‰§è¡Œboot.wimç´§æ€¥æ¸…ç†...")
b.regMgr.UnloadHives()
b.imgMgr.UnmountImage(false)
}
}()
if err := b.regMgr.LoadHives(); err != nil {
return err
}
if err := b.regMgr.ApplyBootTweaks(); err != nil {
b.log.Warn("åº”ç”¨Bootä¼˜åŒ–å¤±è´¥: %v", err)
}
b.regMgr.UnloadHives()
if err := b.imgMgr.UnmountImage(true); err != nil {
return err
}
bootUnmounted = true
return nil
}
func (b *Tiny11Builder) GetOutputISO() string {
return b.outputISO
}
```

### 6. internal\app\core_builder.go

```go
package app
import (
"fmt"
"tiny11-builder/internal/config"
"tiny11-builder/internal/logger"
"tiny11-builder/internal/remover"
"tiny11-builder/internal/utils"
)
type Tiny11CoreBuilder struct {
*Tiny11Builder
coreRemover *remover.CoreRemover
}
func NewTiny11CoreBuilder(cfg *config.Config, log *logger.Logger) *Tiny11CoreBuilder {
return &Tiny11CoreBuilder{
Tiny11Builder: NewTiny11Builder(cfg, log), coreRemover: remover.NewCoreRemover(cfg, log), }
}
func (b *Tiny11CoreBuilder) Build() error {
b.log.Header("Tiny11 Core Builder - ä¸å¯æœåŠ¡ç‰ˆæœ¬")
var imageUnmounted = false
b.log.Step(1, "éªŒè¯ISOé•œåƒ")
if err := b.imgMgr.ValidateISO(); err != nil {
return fmt.Errorf("ISOéªŒè¯å¤±è´¥: %w", err)
}
b.log.Step(2, "å¤åˆ¶Windowsé•œåƒæ–‡ä»¶")
if err := b.imgMgr.CopyImageFiles(); err != nil {
return fmt.Errorf("å¤åˆ¶æ–‡ä»¶å¤±è´¥: %w", err)
}
b.log.Step(3, "è·å–é•œåƒä¿¡æ¯")
imageInfo, err := b.imgMgr.GetImageInfo()
if err != nil {
return fmt.Errorf("è·å–é•œåƒä¿¡æ¯å¤±è´¥: %w", err)
}
b.log.Step(4, "æŒ‚è½½install.wim")
if err := b.imgMgr.MountInstallWim(imageInfo.Index); err != nil {
return fmt.Errorf("æŒ‚è½½å¤±è´¥: %w", err)
}
defer func() {
if !imageUnmounted {
b.log.Info("æ‰§è¡Œç´§æ€¥æ¸…ç†...")
b.regMgr.UnloadHives()
b.imgMgr.UnmountImage(false)
}
}()
b.log.Step(5, "ç§»é™¤é¢„è£…åº”ç”¨")
if err := b.remover.RemoveProvisionedApps(); err != nil {
return fmt.Errorf("ç§»é™¤åº”ç”¨å¤±è´¥: %w", err)
}
b.log.Step(6, "ç§»é™¤ç³»ç»Ÿç»„ä»¶")
if err := b.remover.RemoveSystemPackages(imageInfo.Language); err != nil {
b.log.Warn("ç§»é™¤ç³»ç»ŸåŒ…å¤±è´¥: %v", err)
}
b.log.Step(7, "é…ç½®.NET Framework 3.5")
if err := b.configureNET35(); err != nil {
b.log.Warn(".NET 3.5é…ç½®å¤±è´¥: %v", err)
}
b.log.Step(8, "ç§»é™¤Edgeå’ŒOneDrive")
b.remover.RemoveEdge()
b.remover.RemoveOneDrive()
b.log.Step(9, "ç§»é™¤WinSxSç»„ä»¶å­˜å‚¨ (ä¿ç•™å¿…è¦ç»„ä»¶)")
if err := b.coreRemover.RemoveWinSxS(); err != nil {
return fmt.Errorf("ç§»é™¤WinSxSå¤±è´¥: %w", err)
}
b.log.Step(10, "ç§»é™¤WinREæ¢å¤ç¯å¢ƒ")
if err := b.coreRemover.RemoveWinRE(); err != nil {
b.log.Warn("ç§»é™¤WinREå¤±è´¥: %v", err)
}
b.log.Step(11, "ç§»é™¤é¥æµ‹è®¡åˆ’ä»»åŠ¡")
b.remover.RemoveScheduledTasks()
b.log.Step(12, "åº”ç”¨æ³¨å†Œè¡¨ä¼˜åŒ–")
if err := b.regMgr.LoadHives(); err != nil {
return fmt.Errorf("åŠ è½½æ³¨å†Œè¡¨å¤±è´¥: %w", err)
}
b.regMgr.ApplyTweaks()
b.regMgr.ApplyCoreTweaks()
b.regMgr.UnloadHives()
b.copyAutounattend()
b.log.Step(13, "å¯¼å‡ºä¼˜åŒ–åçš„é•œåƒ")
if err := b.imgMgr.UnmountImage(true); err != nil {
return fmt.Errorf("å¸è½½å¤±è´¥: %w", err)
}
imageUnmounted = true
if err := b.imgMgr.ExportImage(imageInfo.Index); err != nil {
return fmt.Errorf("å¯¼å‡ºå¤±è´¥: %w", err)
}
b.log.Step(14, "å¤„ç†boot.wim")
if err := b.processBootWim(); err != nil {
return fmt.Errorf("å¤„ç†boot.wimå¤±è´¥: %w", err)
}
b.log.Step(15, "åˆ›å»ºISOé•œåƒ")
isoPath, err := b.imgMgr.CreateISO()
if err != nil {
return fmt.Errorf("åˆ›å»ºISOå¤±è´¥: %w", err)
}
b.outputISO = isoPath
b.log.Step(16, "æ¸…ç†ä¸´æ—¶æ–‡ä»¶")
b.imgMgr.Cleanup()
return nil
}
func (b *Tiny11CoreBuilder) configureNET35() error {
fmt.Println()
fmt.Print(utils.Colorize("æ˜¯å¦å¯ç”¨.NET Framework 3.5? è¿™ä¸èƒ½åœ¨é•œåƒåˆ›å»ºåè¿›è¡Œ! [y/N]: ", utils.MikuPink))
var response string
fmt.Scanln(&response)
if response == "y" || response == "Y" {
b.log.Info("å¯ç”¨.NET Framework 3.5...")
mountPath := b.config.ScratchDir
sxsPath := b.config.ISODrive + "\\sources\\sxs"
spinner := utils.NewSpinner("å®‰è£….NET Framework 3.5 (è¿™å¯èƒ½éœ€è¦å‡ åˆ†é’Ÿ)...")
spinner.Start()
_, err := utils.RunCommand("dism", fmt.Sprintf("/Image:%s", mountPath), "/Enable-Feature", "/FeatureName:NetFX3", "/All", fmt.Sprintf("/Source:%s", sxsPath))
spinner.Stop(err == nil)
if err != nil {
return fmt.Errorf("å¯ç”¨.NET 3.5å¤±è´¥: %w", err)
}
b.log.Success(".NET Framework 3.5å·²å¯ç”¨")
} else {
b.log.Info("è·³è¿‡.NET Framework 3.5å®‰è£…")
}
return nil
}
```

### 7. internal\app\interface.go

```go
package app
type Builder interface {
Build() error
GetOutputISO() string
}
```

### 8. internal\app\nano_builder.go

```go
package app
import (
"fmt"
"os"
"path/filepath"
"runtime"
"strings"
"tiny11-builder/internal/config"
"tiny11-builder/internal/logger"
"tiny11-builder/internal/remover"
"tiny11-builder/internal/utils"
)
type Tiny11NanoBuilder struct {
*Tiny11CoreBuilder
nanoRemover *remover.NanoRemover
}
func NewTiny11NanoBuilder(cfg *config.Config, log *logger.Logger) *Tiny11NanoBuilder {
return &Tiny11NanoBuilder{
Tiny11CoreBuilder: NewTiny11CoreBuilder(cfg, log), nanoRemover: remover.NewNanoRemover(cfg, log), }
}
func (b *Tiny11NanoBuilder) Build() error {
b.log.Header("Tiny11 Nano Builder - ç»ˆæç²¾ç®€ç‰ˆæœ¬")
b.log.Warn("âš ï¸  è­¦å‘Šï¼šæ­¤ç‰ˆæœ¬å°†ç§»é™¤å‡ ä¹æ‰€æœ‰å¯ç§»é™¤ç»„ä»¶ï¼Œä»…ç”¨äºæç«¯æµ‹è¯•åœºæ™¯ï¼")
var imageUnmounted = false
b.log.Step(1, "éªŒè¯ ISO é•œåƒ")
if err := b.imgMgr.ValidateISO(); err != nil {
return fmt.Errorf("ISO éªŒè¯å¤±è´¥: %w", err)
}
b.log.Step(2, "å¤åˆ¶ Windows é•œåƒæ–‡ä»¶")
if err := b.imgMgr.CopyImageFiles(); err != nil {
return fmt.Errorf("å¤åˆ¶æ–‡ä»¶å¤±è´¥: %w", err)
}
b.log.Step(3, "è·å–é•œåƒä¿¡æ¯")
imageInfo, err := b.imgMgr.GetImageInfo()
if err != nil {
return fmt.Errorf("è·å–é•œåƒä¿¡æ¯å¤±è´¥: %w", err)
}
b.log.Info("æ¶æ„: %s, è¯­è¨€: %s, ç´¢å¼•: %d", imageInfo.Architecture, imageInfo.Language, imageInfo.Index)
b.log.Step(4, "æŒ‚è½½ install.wim")
if err := b.imgMgr.MountInstallWim(imageInfo.Index); err != nil {
return fmt.Errorf("æŒ‚è½½å¤±è´¥: %w", err)
}
defer func() {
if !imageUnmounted {
b.log.Info("æ‰§è¡Œç´§æ€¥æ¸…ç†...")
b.regMgr.UnloadHives()
b.imgMgr.UnmountImage(false)
}
}()
b.log.Step(5, "é¢„é˜²æ€§è·å–å…³é”®æ–‡ä»¶å¤¹æ‰€æœ‰æƒ")
if err := b.proactivelyTakeOwnership(); err != nil {
b.log.Warn("è·å–æ‰€æœ‰æƒå¤±è´¥ï¼ˆéƒ¨åˆ†ï¼‰: %v", err)
}
b.log.Step(6, "ç§»é™¤é¢„è£…åº”ç”¨")
if err := b.remover.RemoveProvisionedApps(); err != nil {
return fmt.Errorf("ç§»é™¤åº”ç”¨å¤±è´¥: %w", err)
}
b.log.Step(7, "ç§»é™¤æ‰©å±•åº”ç”¨åˆ—è¡¨ (Nano)")
if err := b.nanoRemover.RemoveAggressiveApps(); err != nil {
b.log.Warn("ç§»é™¤æ‰©å±•åº”ç”¨å¤±è´¥: %v", err)
}
b.log.Step(8, "ç§»é™¤ç³»ç»Ÿç»„ä»¶åŒ… (Nano)")
if err := b.nanoRemover.RemoveAggressivePackages(imageInfo.Language); err != nil {
b.log.Warn("ç§»é™¤ç³»ç»ŸåŒ…å¤±è´¥: %v", err)
}
b.log.Step(9, "ç§»é™¤é¢„ç¼–è¯‘ .NET ç¨‹åºé›†")
if err := b.nanoRemover.RemoveNativeImages(); err != nil {
b.log.Warn("ç§»é™¤ Native Images å¤±è´¥: %v", err)
}
b.log.Step(10, "ç²¾ç®€é©±åŠ¨ç¨‹åºå­˜å‚¨")
if err := b.nanoRemover.SlimDriverStore(); err != nil {
b.log.Warn("ç²¾ç®€ DriverStore å¤±è´¥: %v", err)
}
b.log.Step(11, "ç²¾ç®€ç³»ç»Ÿå­—ä½“")
if err := b.nanoRemover.SlimFonts(); err != nil {
b.log.Warn("ç²¾ç®€å­—ä½“å¤±è´¥: %v", err)
}
b.log.Step(12, "ç§»é™¤éå¿…éœ€ç³»ç»Ÿæ–‡ä»¶å¤¹")
if err := b.nanoRemover.RemoveSystemFolders(); err != nil {
b.log.Warn("ç§»é™¤ç³»ç»Ÿæ–‡ä»¶å¤¹å¤±è´¥: %v", err)
}
b.log.Step(13, "ç§»é™¤ Edgeã€OneDrive å’Œ WinRE")
b.remover.RemoveEdge()
b.remover.RemoveOneDrive()
b.coreRemover.RemoveWinRE()
b.log.Step(14, "æ¸…ç†é•œåƒç»„ä»¶")
if err := b.imgMgr.CleanupImage(); err != nil {
b.log.Warn("æ¸…ç†å¤±è´¥ï¼ˆç»§ç»­ï¼‰: %v", err)
}
b.log.Step(15, "ç²¾ç®€ WinSxS ç»„ä»¶å­˜å‚¨")
if err := b.coreRemover.RemoveWinSxS(); err != nil {
return fmt.Errorf("ç²¾ç®€ WinSxS å¤±è´¥: %w", err)
}
b.log.Step(16, "åº”ç”¨æ³¨å†Œè¡¨ä¼˜åŒ–")
if err := b.regMgr.LoadHives(); err != nil {
return fmt.Errorf("åŠ è½½æ³¨å†Œè¡¨å¤±è´¥: %w", err)
}
b.regMgr.ApplyTweaks()
b.regMgr.ApplyCoreTweaks()
b.regMgr.ApplyNanoTweaks()
b.regMgr.UnloadHives()
b.log.Step(17, "ç§»é™¤éå¿…éœ€ç³»ç»ŸæœåŠ¡")
if err := b.nanoRemover.RemoveSystemServices(); err != nil {
b.log.Warn("ç§»é™¤æœåŠ¡å¤±è´¥: %v", err)
}
b.copyAutounattend()
b.log.Step(19, "å¸è½½å¹¶æäº¤æ›´æ”¹")
if err := b.imgMgr.UnmountImage(true); err != nil {
return fmt.Errorf("å¸è½½å¤±è´¥: %w", err)
}
imageUnmounted = true
b.log.Step(20, "å¯¼å‡ºä¸º ESD æ ¼å¼ (è¶…é«˜å‹ç¼©)")
if err := b.exportImageToESD(imageInfo.Index); err != nil {
return fmt.Errorf("å¯¼å‡º ESD å¤±è´¥: %w", err)
}
b.log.Step(21, "ç²¾ç®€ boot.wim")
if err := b.processNanoBootWim(); err != nil {
return fmt.Errorf("å¤„ç† boot.wim å¤±è´¥: %w", err)
}
b.log.Step(22, "æ¸…ç† ISO æ ¹ç›®å½•")
if err := b.cleanupISORoot(); err != nil {
b.log.Warn("æ¸…ç† ISO æ ¹ç›®å½•å¤±è´¥: %v", err)
}
b.log.Step(23, "åˆ›å»º ISO é•œåƒ")
isoPath, err := b.imgMgr.CreateISO()
if err != nil {
return fmt.Errorf("åˆ›å»º ISO å¤±è´¥: %w", err)
}
b.outputISO = isoPath
b.log.Step(24, "æ¸…ç†ä¸´æ—¶æ–‡ä»¶")
b.imgMgr.Cleanup()
runtime.GC()
return nil
}
func (b *Tiny11NanoBuilder) proactivelyTakeOwnership() error {
scratchDir := b.config.ScratchDir
foldersToOwn := []string{
filepath.Join(scratchDir, "Windows", "System32", "DriverStore", "FileRepository"), filepath.Join(scratchDir, "Windows", "Fonts"), filepath.Join(scratchDir, "Windows", "Web"), filepath.Join(scratchDir, "Windows", "Help"), filepath.Join(scratchDir, "Windows", "Cursors"), filepath.Join(scratchDir, "Program Files (x86)", "Microsoft"), filepath.Join(scratchDir, "Program Files", "WindowsApps"), filepath.Join(scratchDir, "Windows", "System32", "Microsoft-Edge-Webview"), filepath.Join(scratchDir, "Windows", "System32", "Recovery"), filepath.Join(scratchDir, "Windows", "WinSxS"), filepath.Join(scratchDir, "Windows", "assembly"), filepath.Join(scratchDir, "ProgramData", "Microsoft", "Windows Defender"), filepath.Join(scratchDir, "Windows", "System32", "InputMethod"), filepath.Join(scratchDir, "Windows", "Speech"), filepath.Join(scratchDir, "Windows", "Temp"), }
filesToOwn := []string{
filepath.Join(scratchDir, "Windows", "System32", "OneDriveSetup.exe"), }
b.log.Info("ä¸»åŠ¨è·å–å…³é”®æ–‡ä»¶å¤¹æ‰€æœ‰æƒ...")
ownedFolders := 0
for _, folder := range foldersToOwn {
if !utils.DirExists(folder) {
continue
}
b.log.Info("  è·å–æ‰€æœ‰æƒ: %s", filepath.Base(folder))
if err := utils.TakeownRecursive(folder); err != nil {
b.log.Warn("  âœ— takeown å¤±è´¥: %v", err)
continue
}
if err := utils.GrantPermissionRecursive(folder); err != nil {
b.log.Warn("  âœ— icacls å¤±è´¥: %v", err)
continue
}
ownedFolders++
}
ownedFiles := 0
for _, file := range filesToOwn {
if !utils.FileExists(file) {
continue
}
b.log.Info("  è·å–æ–‡ä»¶æ‰€æœ‰æƒ: %s", filepath.Base(file))
if err := utils.Takeown(file); err != nil {
b.log.Warn("  âœ— takeown å¤±è´¥: %v", err)
continue
}
if err := utils.GrantPermission(file); err != nil {
b.log.Warn("  âœ— icacls å¤±è´¥: %v", err)
continue
}
ownedFiles++
}
b.log.Success("è·å–äº† %d ä¸ªæ–‡ä»¶å¤¹å’Œ %d ä¸ªæ–‡ä»¶çš„æ‰€æœ‰æƒ", ownedFolders, ownedFiles)
return nil
}
func (b *Tiny11NanoBuilder) exportImageToESD(index int) error {
sourceWim := filepath.Join(b.config.Tiny11Dir, "sources", "install.wim")
destEsd := filepath.Join(b.config.Tiny11Dir, "sources", "install.esd")
b.log.Info("å¯¼å‡ºä¸º ESD æ ¼å¼ (recovery å‹ç¼©)...")
if !utils.FileExists(sourceWim) {
return fmt.Errorf("æº WIM æ–‡ä»¶ä¸å­˜åœ¨: %s", sourceWim)
}
if utils.FileExists(destEsd) {
os.Remove(destEsd)
}
spinner := utils.NewSpinner("å¯¼å‡ºä¸º ESD æ ¼å¼ (è¿™å°†èŠ±è´¹è¾ƒé•¿æ—¶é—´ä½†æ–‡ä»¶æ›´å°)")
spinner.Start()
_, err := utils.RunCommand("dism", "/English", "/Export-Image", fmt.Sprintf("/SourceImageFile:%s", sourceWim), "/SourceIndex:1", fmt.Sprintf("/DestinationImageFile:%s", destEsd), "/Compress:recovery")
spinner.Stop(err == nil)
if err != nil {
return fmt.Errorf("å¯¼å‡º ESD å¤±è´¥: %w", err)
}
if !utils.FileExists(destEsd) {
return fmt.Errorf("ESD æ–‡ä»¶åˆ›å»ºå¤±è´¥")
}
esdInfo, err := os.Stat(destEsd)
if err != nil {
return fmt.Errorf("æ— æ³•è·å– ESD æ–‡ä»¶ä¿¡æ¯: %w", err)
}
wimInfo, _ := os.Stat(sourceWim)
b.log.Success("å·²å¯¼å‡ºä¸º ESD æ ¼å¼")
if wimInfo != nil {
b.log.Info("  WIM å¤§å°: %s", utils.FormatBytes(wimInfo.Size()))
}
b.log.Info("  ESD å¤§å°: %s", utils.FormatBytes(esdInfo.Size()))
if wimInfo != nil {
saved := wimInfo.Size() - esdInfo.Size()
ratio := float64(saved) / float64(wimInfo.Size()) * 100
b.log.Info("  èŠ‚çœç©ºé—´: %s (%.1f%%)", utils.FormatBytes(saved), ratio)
}
os.Remove(sourceWim)
return nil
}
func (b *Tiny11NanoBuilder) processNanoBootWim() error {
bootWimPath := filepath.Join(b.config.Tiny11Dir, "sources", "boot.wim")
newBootWimPath := filepath.Join(b.config.Tiny11Dir, "sources", "boot_new.wim")
finalBootWimPath := filepath.Join(b.config.Tiny11Dir, "sources", "boot_final.wim")
b.log.Info("è·å– boot.wim æ‰€æœ‰æƒ...")
utils.Takeown(bootWimPath)
utils.GrantPermission(bootWimPath)
os.Chmod(bootWimPath, 0666)
b.log.Info("å¯¼å‡º boot.wim ç´¢å¼• 2...")
spinner := utils.NewSpinner("å¯¼å‡º boot.wim")
spinner.Start()
_, err := utils.RunCommand("dism", "/English", "/Export-Image", fmt.Sprintf("/SourceImageFile:%s", bootWimPath), "/SourceIndex:2", fmt.Sprintf("/DestinationImageFile:%s", newBootWimPath))
spinner.Stop(err == nil)
if err != nil {
return fmt.Errorf("å¯¼å‡º boot.wim å¤±è´¥: %w", err)
}
b.log.Info("æŒ‚è½½ boot.wim...")
if err := b.imgMgr.MountBootWim(); err != nil {
mountPath := b.config.ScratchDir
_, err = utils.RunCommand("dism", "/English", "/Mount-Image", fmt.Sprintf("/ImageFile:%s", newBootWimPath), "/Index:1", fmt.Sprintf("/MountDir:%s", mountPath))
if err != nil {
return fmt.Errorf("æŒ‚è½½ boot.wim å¤±è´¥: %w", err)
}
}
if err := b.regMgr.LoadHives(); err != nil {
b.log.Warn("åŠ è½½ boot.wim æ³¨å†Œè¡¨å¤±è´¥: %v", err)
} else {
b.regMgr.ApplyBootTweaks()
b.regMgr.UnloadHives()
}
b.log.Info("å¸è½½ boot.wim...")
if err := b.imgMgr.UnmountImage(true); err != nil {
b.log.Warn("å¸è½½ boot.wim å¤±è´¥: %v", err)
}
runtime.GC()
utils.Sleep(5)
utils.Takeown(bootWimPath)
utils.GrantPermission(bootWimPath)
os.Chmod(bootWimPath, 0666)
os.Remove(bootWimPath)
b.log.Info("å‹ç¼© boot.wim...")
spinner = utils.NewSpinner("æœ€ç»ˆå‹ç¼© boot.wim")
spinner.Start()
_, err = utils.RunCommand("dism", "/English", "/Export-Image", fmt.Sprintf("/SourceImageFile:%s", newBootWimPath), "/SourceIndex:1", fmt.Sprintf("/DestinationImageFile:%s", finalBootWimPath), "/Compress:max")
spinner.Stop(err == nil)
if err != nil {
return fmt.Errorf("å‹ç¼© boot.wim å¤±è´¥: %w", err)
}
os.Remove(newBootWimPath)
os.Rename(finalBootWimPath, bootWimPath)
b.log.Success("boot.wim å¤„ç†å®Œæˆ")
return nil
}
func (b *Tiny11NanoBuilder) cleanupISORoot() error {
isoRoot := b.config.Tiny11Dir
keepList := map[string]bool{
"boot": true, "efi": true, "sources": true, "bootmgr": true, "bootmgr.efi": true, "setup.exe": true, "autounattend.xml": true, }
entries, err := os.ReadDir(isoRoot)
if err != nil {
return err
}
removed := 0
for _, entry := range entries {
entryNameLower := strings.ToLower(entry.Name())
if !keepList[entryNameLower] {
path := filepath.Join(isoRoot, entry.Name())
b.log.Info("ç§»é™¤éå¿…éœ€é¡¹: %s", entry.Name())
if err := os.RemoveAll(path); err != nil {
b.log.Warn("  âœ— å¤±è´¥: %v", err)
} else {
removed++
}
}
}
b.log.Success("æ¸…ç†äº† %d ä¸ªéå¿…éœ€æ–‡ä»¶/æ–‡ä»¶å¤¹", removed)
return nil
}
```

### 9. internal\cli\admin.go

```go
package cli
import (
"golang.org/x/sys/windows"
)
func IsAdmin() bool {
var sid *windows.SID
err := windows.AllocateAndInitializeSid(
&windows.SECURITY_NT_AUTHORITY, 2, windows.SECURITY_BUILTIN_DOMAIN_RID, windows.DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &sid)
if err != nil {
return false
}
defer windows.FreeSid(sid)
token := windows.Token(0)
member, err := token.IsMember(sid)
if err != nil {
return false
}
return member
}
```

### 10. internal\cli\args.go

```go
package cli
import (
"flag"
"fmt"
"strings"
"tiny11-builder/internal/config"
)
func ParseArgsUnified(args []string) (*config.Config, string, string, error) {
fs := flag.NewFlagSet("tiny11-builder", flag.ContinueOnError)
iso := fs.String("iso", "", "ISOæŒ‚è½½çš„é©±åŠ¨å™¨å· (ä¾‹: E)")
scratch := fs.String("scratch", "", "ä¸´æ—¶æ–‡ä»¶é©±åŠ¨å™¨å· (ä¾‹: D)")
index := fs.Int("index", 0, "é•œåƒç´¢å¼• (0=è‡ªåŠ¨é€‰æ‹©)")
output := fs.String("output", "", "è¾“å‡ºISOè·¯å¾„")
mode := fs.String("mode", "", "æ„å»ºæ¨¡å¼: standard æˆ– core")
theme := fs.String("theme", "default", "ä¸»é¢˜åç§°: default, miku æˆ–è‡ªå®šä¹‰")
verbose := fs.Bool("v", false, "è¯¦ç»†æ—¥å¿—")
help := fs.Bool("h", false, "æ˜¾ç¤ºå¸®åŠ©")
if err := fs.Parse(args); err != nil {
return nil, "", "", err
}
if *help {
PrintUsageUnified()
return nil, "", "", fmt.Errorf("æ˜¾ç¤ºå¸®åŠ©")
}
cfg := config.NewConfig()
cfg.Verbose = *verbose
if *iso != "" {
*iso = strings.ToUpper(strings.TrimSuffix(*iso, ":"))
if len(*iso) != 1 || (*iso)[0] < 'C' || (*iso)[0] > 'Z' {
return nil, "", "", fmt.Errorf("æ— æ•ˆçš„é©±åŠ¨å™¨å·: %s", *iso)
}
cfg.ISODrive = *iso + ":"
} else {
fmt.Print("è¯·è¾“å…¥Windows 11 ISOæŒ‚è½½çš„é©±åŠ¨å™¨å·: ")
var drive string
fmt.Scanln(&drive)
drive = strings.ToUpper(strings.TrimSuffix(drive, ":"))
if len(drive) != 1 || drive[0] < 'C' || drive[0] > 'Z' {
return nil, "", "", fmt.Errorf("æ— æ•ˆçš„é©±åŠ¨å™¨å·: %s", drive)
}
cfg.ISODrive = drive + ":"
}
if *scratch != "" {
*scratch = strings.ToUpper(strings.TrimSuffix(*scratch, ":"))
cfg.ScratchDrive = *scratch + ":"
}
cfg.ImageIndex = *index
if *output != "" {
cfg.OutputISO = *output
}
cfg.ThemeName = *theme
buildMode := strings.ToLower(*mode)
if buildMode != "" && buildMode != "standard" && buildMode != "core" {
return nil, "", "", fmt.Errorf("æ— æ•ˆçš„æ¨¡å¼: %s (åº”ä¸º standard æˆ– core)", *mode)
}
return cfg, buildMode, *theme, nil
}
func ParseArgs(args []string) (*config.Config, error) {
cfg, _, _, err := ParseArgsUnified(args)
return cfg, err
}
func PrintUsageUnified() {
fmt.Print(`
Tiny11 Builder - Windows 11ç²¾ç®€é•œåƒæ„å»ºå·¥å…· (ç»Ÿä¸€ç‰ˆ)

ç”¨æ³•:
  tiny11builder.exe [é€‰é¡¹]

é€‰é¡¹:
  -iso <drive>      ISOæŒ‚è½½çš„é©±åŠ¨å™¨å· (ä¾‹: -iso E)
  -scratch <drive>  ä¸´æ—¶æ–‡ä»¶é©±åŠ¨å™¨å· (ä¾‹: -scratch D)
  -mode <mode>      æ„å»ºæ¨¡å¼: standard (æ ‡å‡†ç‰ˆ) æˆ– core (æé™ç²¾ç®€)
  -theme <name>     ä¸»é¢˜åç§°: default, miku æˆ–è‡ªå®šä¹‰ä¸»é¢˜å
  -index <number>   é•œåƒç´¢å¼• (é»˜è®¤è‡ªåŠ¨é€‰æ‹©)
  -output <path>    è¾“å‡ºISOè·¯å¾„ (é»˜è®¤: ./tiny11.iso)
  -v                è¯¦ç»†æ—¥å¿—è¾“å‡º
  -h                æ˜¾ç¤ºæ­¤å¸®åŠ©

æ„å»ºæ¨¡å¼:
  standard          æ ‡å‡†ç‰ˆ - ç§»é™¤è†¨èƒ€è½¯ä»¶ï¼Œä¿ç•™å¯æœåŠ¡æ€§
                    â€¢ å¯å®‰è£…æ›´æ–°å’ŒåŠŸèƒ½
                    â€¢ é€‚åˆæ—¥å¸¸ä½¿ç”¨
                    â€¢ å¤§å°: çº¦5-6 GB

  core              Coreç‰ˆ - æé™ç²¾ç®€ï¼Œä¸å¯æœåŠ¡
                    â€¢ ç§»é™¤WinSxSå¤§éƒ¨åˆ†å†…å®¹
                    â€¢ ç¦ç”¨æ›´æ–°å’ŒDefender
                    â€¢ ä»…ç”¨äºæµ‹è¯•ç¯å¢ƒ
                    â€¢ å¤§å°: çº¦4-5 GB

ä¸»é¢˜:
  default           é»˜è®¤ - ä¿æŒWindowsåŸæ ·
  miku              Mikuä¸»é¢˜ - é’è‰²å’Œç²‰è‰²é…è‰²ï¼Œè‡ªå®šä¹‰å“ç‰Œ

ç¤ºä¾‹:
  # äº¤äº’å¼æ¨¡å¼ï¼ˆæ¨èï¼‰
  tiny11builder.exe

  # ä½¿ç”¨å‘½ä»¤è¡Œå‚æ•°
  tiny11builder.exe -iso E -mode standard
  tiny11builder.exe -iso E -mode standard -theme miku
  tiny11builder.exe -iso E -scratch D -mode core -v

  # è‡ªåŠ¨åŒ–æ„å»º
  tiny11builder.exe -iso E -mode standard -theme miku -index 3 -output "D:\miku_tiny11.iso"
`)
}
func PrintUsage() {
PrintUsageUnified()
}
```

### 11. internal\config\config.go

```go
package config
import (
"os"
"path/filepath"
"runtime"
)
type Config struct {
ISODrive string
ScratchDrive string
ImageIndex int
OutputISO string
Verbose bool
CoreMode bool
ThemeName string
PreinstallApps []string
WorkDir string
Tiny11Dir string
ScratchDir string
ResourcesDir string
ThemesDir string
PreinstallDir string
TempDir string
LogDir string
}
func NewConfig() *Config {
exePath, _ := os.Executable()
workDir := filepath.Dir(exePath)
if filepath.Base(filepath.Dir(exePath)) == "go-build" {
workDir, _ = os.Getwd()
}
cfg := &Config{
WorkDir: workDir, ThemeName: "default", }
cfg.Tiny11Dir = filepath.Join(workDir, "build", "tiny11")
cfg.ScratchDir = filepath.Join(workDir, "build", "scratch")
cfg.TempDir = filepath.Join(workDir, "build", "temp")
cfg.ResourcesDir = filepath.Join(workDir, "resources")
cfg.ThemesDir = filepath.Join(workDir, "themes")
cfg.PreinstallDir = filepath.Join(workDir, "preinstall")
cfg.LogDir = filepath.Join(workDir, "logs")
cfg.OutputISO = filepath.Join(workDir, "tiny11.iso")
cfg.ScratchDrive = detectSystemDrive()
return cfg
}
func detectSystemDrive() string {
if drive := os.Getenv("SystemDrive"); drive != "" {
return drive
}
return "C:"
}
func (c *Config) GetArchitecture() string {
arch := runtime.GOARCH
switch arch {
case "amd64":
return "amd64"
case "arm64":
return "arm64"
default:
return arch
}
}
func (c *Config) EnsureDirectories() error {
dirs := []string{
c.Tiny11Dir, c.ScratchDir, c.TempDir, c.LogDir, filepath.Join(c.WorkDir, "build"), }
for _, dir := range dirs {
if err := os.MkdirAll(dir, 0755); err != nil {
return err
}
}
return nil
}
func (c *Config) Cleanup() error {
buildDir := filepath.Join(c.WorkDir, "build")
if err := os.RemoveAll(buildDir); err != nil {
return err
}
return nil
}
```

### 12. internal\image\manager.go

```go
package image
import (
"fmt"
"os"
"path/filepath"
"runtime"
"strings"
"syscall"
"time"
"unsafe"
"tiny11-builder/internal/config"
"tiny11-builder/internal/logger"
"tiny11-builder/internal/types"
"tiny11-builder/internal/utils"
)
type Manager struct {
config *config.Config
log *logger.Logger
info *ImageInfo
}
type ImageInfo struct {
Index int
Name string
Architecture string
Language string
Build string
Description string
Size int64
}
func NewManager(cfg *config.Config, log *logger.Logger) *Manager {
return &Manager{
config: cfg, log: log, }
}
func (m *Manager) ValidateISO() error {
bootWim := filepath.Join(m.config.ISODrive, "sources", "boot.wim")
installWim := filepath.Join(m.config.ISODrive, "sources", "install.wim")
installEsd := filepath.Join(m.config.ISODrive, "sources", "install.esd")
spinner := utils.NewSpinner("éªŒè¯ISOé•œåƒå®Œæ•´æ€§...")
spinner.Start()
if !utils.FileExists(bootWim) {
spinner.Stop(false)
return types.NewError(types.ErrCodeNotFound, "æœªæ‰¾åˆ°boot.wim", nil).
WithContext("path", bootWim)
}
hasWim := utils.FileExists(installWim)
hasEsd := utils.FileExists(installEsd)
if !hasWim && !hasEsd {
spinner.Stop(false)
return types.NewError(types.ErrCodeNotFound, "æœªæ‰¾åˆ°install.wimæˆ–install.esd", nil)
}
spinner.Stop(true)
if !hasWim && hasEsd {
m.log.Info("æ£€æµ‹åˆ°install.esdï¼Œéœ€è¦è½¬æ¢ä¸ºinstall.wim")
if err := m.convertEsdToWim(installEsd); err != nil {
return types.NewError(types.ErrCodeDISM, "è½¬æ¢ESDå¤±è´¥", err)
}
}
return nil
}
func (m *Manager) convertEsdToWim(esdPath string) error {
m.log.Section("è½¬æ¢ESDé•œåƒæ ¼å¼")
output, err := utils.RunCommand("dism", "/English", "/Get-WimInfo", fmt.Sprintf("/WimFile:%s", esdPath))
if err != nil {
return fmt.Errorf("è·å–ESDä¿¡æ¯å¤±è´¥: %w", err)
}
fmt.Println()
lines := m.parseImageList(output)
for _, line := range lines {
if strings.HasPrefix(line, "Index :") {
fmt.Println(utils.Colorize(line, utils.MikuCyan))
} else {
fmt.Println(utils.Colorize(line, utils.MikuWhite))
}
}
fmt.Println()
index := m.config.ImageIndex
if index == 0 {
fmt.Print(utils.Colorize("è¯·è¾“å…¥è¦è½¬æ¢çš„é•œåƒç´¢å¼•: ", utils.MikuPink))
fmt.Scanln(&index)
}
destWim := filepath.Join(m.config.Tiny11Dir, "sources", "install.wim")
os.MkdirAll(filepath.Dir(destWim), 0755)
m.log.Info("æ­£åœ¨è½¬æ¢é•œåƒï¼Œè¿™å¯èƒ½éœ€è¦10-30åˆ†é’Ÿ...")
spinner := utils.NewSpinner("è½¬æ¢install.esdåˆ°install.wim")
spinner.Start()
_, err = utils.RunCommand("dism", "/English", "/Export-Image", fmt.Sprintf("/SourceImageFile:%s", esdPath), fmt.Sprintf("/SourceIndex:%d", index), fmt.Sprintf("/DestinationImageFile:%s", destWim), "/Compress:max", "/CheckIntegrity")
spinner.Stop(err == nil)
if err != nil {
return fmt.Errorf("è½¬æ¢å¤±è´¥: %w", err)
}
m.log.Success("ESDè½¬æ¢å®Œæˆ")
return nil
}
func (m *Manager) CopyImageFiles() error {
m.log.Info("æ­£åœ¨åˆ†æISOé•œåƒç»“æ„...")
spinner := utils.NewSpinner("è®¡ç®—æ–‡ä»¶æ€»å¤§å°...")
spinner.Start()
totalSize, fileCount, err := m.getDirSizeAndCount(m.config.ISODrive)
if err != nil {
spinner.Stop(false)
return types.NewError(types.ErrCodeGeneral, "è®¡ç®—æ–‡ä»¶å¤§å°å¤±è´¥", err)
}
spinner.Stop(true)
m.log.Info("ISOé•œåƒå¤§å°: %s, æ–‡ä»¶æ•°: %d", utils.FormatBytes(totalSize), fileCount)
if err := os.MkdirAll(m.config.Tiny11Dir, 0755); err != nil {
return types.NewError(types.ErrCodePermission, "åˆ›å»ºç›®æ ‡ç›®å½•å¤±è´¥", err)
}
progress := utils.NewProgressBar(totalSize, "å¤åˆ¶é•œåƒæ–‡ä»¶")
err = utils.CopyDirConcurrent(m.config.ISODrive, m.config.Tiny11Dir, progress)
progress.Finish()
if err != nil {
return types.NewError(types.ErrCodeGeneral, "å¤åˆ¶æ–‡ä»¶å¤±è´¥", err)
}
esdPath := filepath.Join(m.config.Tiny11Dir, "sources", "install.esd")
if utils.FileExists(esdPath) {
m.log.Info("ç§»é™¤install.esd...")
os.Chmod(esdPath, 0666)
if err := os.Remove(esdPath); err != nil {
m.log.Warn("æ— æ³•åˆ é™¤install.esd: %v", err)
}
}
runtime.GC()
m.log.Success("é•œåƒæ–‡ä»¶å¤åˆ¶å®Œæˆ")
return nil
}
func (m *Manager) getDirSizeAndCount(path string) (int64, int, error) {
var size int64
var count int
err := filepath.Walk(path, func(filePath string, info os.FileInfo, err error) error {
if err != nil {
return nil
}
if !info.IsDir() {
size += info.Size()
count++
}
return nil
})
if err != nil {
return 0, 0, err
}
return size, count, nil
}
func (m *Manager) GetImageInfo() (*ImageInfo, error) {
wimPath := filepath.Join(m.config.Tiny11Dir, "sources", "install.wim")
if !utils.FileExists(wimPath) {
return nil, types.NewError(types.ErrCodeNotFound, "install.wimä¸å­˜åœ¨", nil).
WithContext("path", wimPath)
}
m.log.Section("è·å–é•œåƒä¿¡æ¯")
output, err := utils.RunCommand("dism", "/English", "/Get-WimInfo", fmt.Sprintf("/WimFile:%s", wimPath))
if err != nil {
return nil, types.NewError(types.ErrCodeDISM, "è·å–é•œåƒä¿¡æ¯å¤±è´¥", err)
}
fmt.Println()
lines := m.parseImageList(output)
for _, line := range lines {
if strings.HasPrefix(line, "Index :") {
fmt.Println(utils.Colorize(line, utils.MikuCyan))
} else if strings.Contains(line, "Name :") {
fmt.Println(utils.Colorize(line, utils.MikuPink))
} else {
fmt.Println(utils.Colorize(line, utils.MikuWhite))
}
}
fmt.Println()
index := m.config.ImageIndex
if index == 0 {
fmt.Print(utils.Colorize("è¯·è¾“å…¥é•œåƒç´¢å¼•: ", utils.MikuPink))
fmt.Scanln(&index)
}
availableIndices := m.extractAvailableIndices(output)
if !m.isValidIndex(index, availableIndices) {
return nil, types.NewError(types.ErrCodeInvalidInput, "æ— æ•ˆçš„é•œåƒç´¢å¼•", nil).
WithContext("index", index)
}
spinner := utils.NewSpinner("è¯»å–é•œåƒè¯¦ç»†ä¿¡æ¯...")
spinner.Start()
output, err = utils.RunCommand("dism", "/English", "/Get-WimInfo", fmt.Sprintf("/WimFile:%s", wimPath), fmt.Sprintf("/Index:%d", index))
spinner.Stop(err == nil)
if err != nil {
return nil, types.NewError(types.ErrCodeDISM, "è·å–è¯¦ç»†ä¿¡æ¯å¤±è´¥", err)
}
info := &ImageInfo{Index: index}
info.Name = utils.ExtractField(output, "Name")
info.Description = utils.ExtractField(output, "Description")
info.Architecture = utils.ExtractField(output, "Architecture")
if info.Architecture == "x64" {
info.Architecture = "amd64"
}
sizeStr := utils.ExtractField(output, "Size")
info.Size = m.parseSizeString(sizeStr)
info.Language = m.detectLanguage(wimPath, index)
m.info = info
fmt.Println()
m.log.Info("é•œåƒè¯¦æƒ…:")
fmt.Printf("  %s %s\n", utils.Colorize("åç§°:", utils.MikuCyan), utils.Colorize(info.Name, utils.MikuWhite))
fmt.Printf("  %s %s\n", utils.Colorize("æ¶æ„:", utils.MikuCyan), utils.Colorize(info.Architecture, utils.MikuWhite))
fmt.Printf("  %s %s\n", utils.Colorize("è¯­è¨€:", utils.MikuCyan), utils.Colorize(info.Language, utils.MikuWhite))
fmt.Printf("  %s %s\n", utils.Colorize("å¤§å°:", utils.MikuCyan), utils.Colorize(utils.FormatBytes(info.Size), utils.MikuWhite))
fmt.Println()
return info, nil
}
func (m *Manager) detectLanguage(wimPath string, index int) string {
mountPath := m.config.ScratchDir
os.MkdirAll(mountPath, 0755)
spinner := utils.NewSpinner("æ£€æµ‹ç³»ç»Ÿè¯­è¨€...")
spinner.Start()
_, err := utils.RunCommand("dism", "/English", "/Mount-Image", fmt.Sprintf("/ImageFile:%s", wimPath), fmt.Sprintf("/Index:%d", index), fmt.Sprintf("/MountDir:%s", mountPath), "/ReadOnly")
language := "en-US"
if err == nil {
langOutput, langErr := utils.RunCommand("dism", "/English", "/Get-Intl", fmt.Sprintf("/Image:%s", mountPath))
if langErr == nil {
language = utils.ExtractLanguage(langOutput)
}
utils.RunCommand("dism", "/English", "/Unmount-Image", fmt.Sprintf("/MountDir:%s", mountPath), "/Discard")
}
spinner.Stop(err == nil)
return language
}
func (m *Manager) MountInstallWim(index int) error {
wimPath := filepath.Join(m.config.Tiny11Dir, "sources", "install.wim")
mountPath := m.config.ScratchDir
wimPath, _ = filepath.Abs(wimPath)
mountPath, _ = filepath.Abs(mountPath)
if !utils.FileExists(wimPath) {
return types.NewError(types.ErrCodeNotFound, "install.wimä¸å­˜åœ¨", nil).
WithContext("path", wimPath)
}
m.log.Info("å‡†å¤‡æŒ‚è½½install.wim (ç´¢å¼•: %d)...", index)
m.log.Info("WIMè·¯å¾„: %s", wimPath)
m.log.Info("æŒ‚è½½ç‚¹: %s", mountPath)
if err := utils.Takeown(wimPath); err != nil {
m.log.Warn("è·å–æ–‡ä»¶æ‰€æœ‰æƒå¤±è´¥: %v", err)
}
if err := utils.GrantPermission(wimPath); err != nil {
m.log.Warn("è®¾ç½®æ–‡ä»¶æƒé™å¤±è´¥: %v", err)
}
os.Chmod(wimPath, 0666)
if utils.DirExists(mountPath) {
m.log.Info("æ¸…ç†ç°æœ‰æŒ‚è½½ç›®å½•...")
utils.RunCommand("dism", "/English", "/Unmount-Image", fmt.Sprintf("/MountDir:%s", mountPath), "/Discard")
time.Sleep(2 * time.Second)
if err := os.RemoveAll(mountPath); err != nil {
m.log.Warn("åˆ é™¤æŒ‚è½½ç›®å½•å¤±è´¥ï¼Œå°è¯•è·å–æƒé™...")
utils.TakeownRecursive(mountPath)
utils.GrantPermissionRecursive(mountPath)
time.Sleep(1 * time.Second)
if err := os.RemoveAll(mountPath); err != nil {
return types.NewError(types.ErrCodePermission, "æ— æ³•æ¸…ç†æŒ‚è½½ç›®å½•", err)
}
}
m.log.Success("æŒ‚è½½ç›®å½•å·²æ¸…ç†")
}
if err := os.MkdirAll(mountPath, 0755); err != nil {
return types.NewError(types.ErrCodePermission, "åˆ›å»ºæŒ‚è½½ç›®å½•å¤±è´¥", err)
}
entries, err := os.ReadDir(mountPath)
if err != nil {
return types.NewError(types.ErrCodeGeneral, "è¯»å–æŒ‚è½½ç›®å½•å¤±è´¥", err)
}
if len(entries) > 0 {
return types.NewError(types.ErrCodeGeneral, "æŒ‚è½½ç›®å½•ä¸ä¸ºç©º", nil).
WithContext("count", len(entries))
}
m.log.Success("æŒ‚è½½ç›®å½•å‡†å¤‡å®Œæˆ")
spinner := utils.NewSpinner(fmt.Sprintf("æŒ‚è½½install.wim (ç´¢å¼• %d)", index))
spinner.Start()
output, err := utils.RunCommand("dism", "/English", "/Mount-Image", fmt.Sprintf("/ImageFile:%s", wimPath), fmt.Sprintf("/Index:%d", index), fmt.Sprintf("/MountDir:%s", mountPath))
spinner.Stop(err == nil)
if err != nil {
m.log.Error("DISMè¾“å‡º: %s", output)
return types.NewError(types.ErrCodeDISM, "æŒ‚è½½å¤±è´¥", err)
}
m.log.Success("é•œåƒæŒ‚è½½æˆåŠŸ")
return nil
}
func (m *Manager) MountBootWim() error {
wimPath := filepath.Join(m.config.Tiny11Dir, "sources", "boot.wim")
mountPath := m.config.ScratchDir
wimPath, _ = filepath.Abs(wimPath)
mountPath, _ = filepath.Abs(mountPath)
if !utils.FileExists(wimPath) {
return types.NewError(types.ErrCodeNotFound, "boot.wimä¸å­˜åœ¨", nil).
WithContext("path", wimPath)
}
m.log.Info("å‡†å¤‡æŒ‚è½½boot.wim...")
utils.Takeown(wimPath)
utils.GrantPermission(wimPath)
os.Chmod(wimPath, 0666)
if utils.DirExists(mountPath) {
m.log.Info("æ¸…ç†ç°æœ‰æŒ‚è½½ç›®å½•...")
utils.RunCommand("dism", "/English", "/Unmount-Image", fmt.Sprintf("/MountDir:%s", mountPath), "/Discard")
time.Sleep(2 * time.Second)
if err := os.RemoveAll(mountPath); err != nil {
utils.TakeownRecursive(mountPath)
utils.GrantPermissionRecursive(mountPath)
time.Sleep(1 * time.Second)
os.RemoveAll(mountPath)
}
}
os.MkdirAll(mountPath, 0755)
spinner := utils.NewSpinner("æŒ‚è½½boot.wim (ç´¢å¼• 2)")
spinner.Start()
_, err := utils.RunCommand("dism", "/English", "/Mount-Image", fmt.Sprintf("/ImageFile:%s", wimPath), "/Index:2", fmt.Sprintf("/MountDir:%s", mountPath))
spinner.Stop(err == nil)
if err != nil {
return types.NewError(types.ErrCodeDISM, "æŒ‚è½½boot.wimå¤±è´¥", err)
}
m.log.Success("boot.wimæŒ‚è½½æˆåŠŸ")
return nil
}
func (m *Manager) UnmountImage(commit bool) error {
mountPath := m.config.ScratchDir
if !m.isMounted(mountPath) {
m.log.Skip("é•œåƒæœªæŒ‚è½½ï¼Œæ— éœ€å¸è½½")
return nil
}
action := "/Discard"
actionDesc := "æ”¾å¼ƒæ›´æ”¹"
if commit {
action = "/Commit"
actionDesc = "ä¿å­˜æ›´æ”¹"
}
m.log.Info("å¸è½½é•œåƒ (%s)...", actionDesc)
spinner := utils.NewSpinner(fmt.Sprintf("å¸è½½é•œåƒ (%s)", actionDesc))
spinner.Start()
_, err := utils.RunCommand("dism", "/English", "/Unmount-Image", fmt.Sprintf("/MountDir:%s", mountPath), action)
spinner.Stop(err == nil)
if err != nil {
return types.NewError(types.ErrCodeDISM, "å¸è½½å¤±è´¥", err)
}
runtime.GC()
m.log.Success("é•œåƒå¸è½½æˆåŠŸ")
return nil
}
func (m *Manager) isMounted(mountPath string) bool {
if !utils.DirExists(mountPath) {
return false
}
entries, err := os.ReadDir(mountPath)
if err != nil || len(entries) == 0 {
return false
}
windowsDir := filepath.Join(mountPath, "Windows")
if !utils.DirExists(windowsDir) {
return false
}
output, err := utils.RunCommand("dism", "/English", "/Get-MountedImageInfo")
if err != nil {
return false
}
return strings.Contains(output, mountPath)
}
func (m *Manager) CleanupImage() error {
mountPath := m.config.ScratchDir
m.log.Info("æ¸…ç†é•œåƒç»„ä»¶å­˜å‚¨...")
spinner := utils.NewSpinner("æ‰§è¡Œç»„ä»¶æ¸…ç† (è¿™å¯èƒ½éœ€è¦å‡ åˆ†é’Ÿ)")
spinner.Start()
output, err := utils.RunCommand("dism", "/English", fmt.Sprintf("/Image:%s", mountPath), "/Cleanup-Image", "/StartComponentCleanup", "/ResetBase")
spinner.Stop(err == nil)
if err != nil {
m.log.Warn("ç»„ä»¶æ¸…ç†å¤±è´¥ï¼Œå°†ä½¿ç”¨å»¶è¿Ÿæ¸…ç†")
_, err2 := utils.RunCommand("dism", "/English", fmt.Sprintf("/Image:%s", mountPath), "/Cleanup-Image", "/StartComponentCleanup")
if err2 != nil {
return types.NewError(types.ErrCodeDISM, "æ¸…ç†å¤±è´¥", err).
WithContext("output", output)
}
m.log.Info("å·²è®¾ç½®å»¶è¿Ÿæ¸…ç†")
return nil
}
runtime.GC()
m.log.Success("é•œåƒæ¸…ç†å®Œæˆ")
return nil
}
func (m *Manager) ExportImage(index int) error {
sourceWim := filepath.Join(m.config.Tiny11Dir, "sources", "install.wim")
destWim := filepath.Join(m.config.Tiny11Dir, "sources", "install2.wim")
m.log.Info("å¯¼å‡ºä¼˜åŒ–åçš„é•œåƒ...")
if !utils.FileExists(sourceWim) {
return types.NewError(types.ErrCodeNotFound, "æºWIMæ–‡ä»¶ä¸å­˜åœ¨", nil).
WithContext("path", sourceWim)
}
sourceInfo, err := os.Stat(sourceWim)
if err != nil {
return types.NewError(types.ErrCodeGeneral, "æ— æ³•è·å–æºæ–‡ä»¶ä¿¡æ¯", err)
}
drive := filepath.VolumeName(destWim)
if drive == "" {
drive = "C:"
}
freeSpace, err := m.getFreeDiskSpace(drive)
if err != nil {
m.log.Warn("æ— æ³•è·å–ç£ç›˜ç©ºé—´ä¿¡æ¯: %v", err)
} else {
requiredSpace := sourceInfo.Size() + (2 * 1024 * 1024 * 1024)
m.log.Info("ç£ç›˜ç©ºé—´æ£€æŸ¥:")
m.log.Info("  å¯ç”¨ç©ºé—´: %s", utils.FormatBytes(int64(freeSpace)))
m.log.Info("  éœ€è¦ç©ºé—´: %s", utils.FormatBytes(requiredSpace))
if int64(freeSpace) < requiredSpace {
return types.NewError(types.ErrCodeDiskSpace, "ç£ç›˜ç©ºé—´ä¸è¶³", nil).
WithContext("available", freeSpace).
WithContext("required", requiredSpace)
}
}
if utils.FileExists(destWim) {
m.log.Info("åˆ é™¤æ—§çš„å¯¼å‡ºæ–‡ä»¶...")
utils.Takeown(destWim)
utils.GrantPermission(destWim)
os.Chmod(destWim, 0666)
if err := os.Remove(destWim); err != nil {
return types.NewError(types.ErrCodePermission, "æ— æ³•åˆ é™¤æ—§æ–‡ä»¶", err).
WithContext("path", destWim)
}
m.log.Success("æ—§æ–‡ä»¶å·²åˆ é™¤")
}
maxRetries := 3
var lastErr error
for attempt := 1; attempt <= maxRetries; attempt++ {
if attempt > 1 {
m.log.Info("ç¬¬ %d æ¬¡é‡è¯•...", attempt)
time.Sleep(2 * time.Second)
}
spinner := utils.NewSpinner(fmt.Sprintf("å¯¼å‡ºé•œåƒ (recoveryå‹ç¼©) - å°è¯• %d/%d", attempt, maxRetries))
spinner.Start()
output, err := utils.RunCommand("dism", "/Export-Image", fmt.Sprintf("/SourceImageFile:%s", sourceWim), fmt.Sprintf("/SourceIndex:%d", index), fmt.Sprintf("/DestinationImageFile:%s", destWim), "/Compress:recovery")
spinner.Stop(err == nil)
if err == nil {
m.log.Success("é•œåƒå¯¼å‡ºæˆåŠŸ")
break
}
lastErr = err
m.log.Warn("å¯¼å‡ºå¤±è´¥: %v", err)
if output != "" {
m.log.Info("DISM è¾“å‡º: %s", output)
}
if utils.FileExists(destWim) {
os.Remove(destWim)
}
if attempt == maxRetries {
return types.NewError(types.ErrCodeDISM, "å¯¼å‡ºå¤±è´¥", lastErr).
WithContext("attempts", maxRetries).
WithContext("output", output)
}
}
if !utils.FileExists(destWim) {
return types.NewError(types.ErrCodeGeneral, "å¯¼å‡ºåæ–‡ä»¶ä¸å­˜åœ¨", nil)
}
destInfo, err := os.Stat(destWim)
if err != nil {
return types.NewError(types.ErrCodeGeneral, "æ— æ³•è·å–å¯¼å‡ºæ–‡ä»¶ä¿¡æ¯", err)
}
if destInfo.Size() < 100*1024*1024 {
return types.NewError(types.ErrCodeGeneral, "å¯¼å‡ºçš„æ–‡ä»¶å¤ªå°ï¼Œå¯èƒ½æŸå", nil).
WithContext("size", destInfo.Size())
}
m.log.Info("å¯¼å‡ºæ–‡ä»¶å¤§å°: %s", utils.FormatBytes(destInfo.Size()))
m.log.Info("æ›¿æ¢åŸå§‹WIMæ–‡ä»¶...")
utils.Takeown(sourceWim)
utils.GrantPermission(sourceWim)
os.Chmod(sourceWim, 0666)
if err := os.Remove(sourceWim); err != nil {
return types.NewError(types.ErrCodePermission, "åˆ é™¤åŸæ–‡ä»¶å¤±è´¥", err)
}
if err := os.Rename(destWim, sourceWim); err != nil {
return types.NewError(types.ErrCodeGeneral, "é‡å‘½åæ–‡ä»¶å¤±è´¥", err)
}
finalInfo, err := os.Stat(sourceWim)
if err != nil {
return types.NewError(types.ErrCodeGeneral, "éªŒè¯æœ€ç»ˆæ–‡ä»¶å¤±è´¥", err)
}
compressionRatio := float64(sourceInfo.Size()-finalInfo.Size()) / float64(sourceInfo.Size()) * 100
m.log.Success("é•œåƒå¯¼å‡ºå®Œæˆ")
m.log.Info("  åŸå§‹å¤§å°: %s", utils.FormatBytes(sourceInfo.Size()))
m.log.Info("  å‹ç¼©å:   %s", utils.FormatBytes(finalInfo.Size()))
m.log.Info("  å‹ç¼©ç‡:   %.1f%%", compressionRatio)
runtime.GC()
return nil
}
func (m *Manager) getFreeDiskSpace(drive string) (uint64, error) {
kernel32 := syscall.NewLazyDLL("kernel32.dll")
getDiskFreeSpaceEx := kernel32.NewProc("GetDiskFreeSpaceExW")
if !strings.HasSuffix(drive, "\\") {
drive = drive + "\\"
}
drivePtr, err := syscall.UTF16PtrFromString(drive)
if err != nil {
return 0, err
}
var freeBytesAvailable uint64
var totalBytes uint64
var totalFreeBytes uint64
ret, _, _ := getDiskFreeSpaceEx.Call(
uintptr(unsafe.Pointer(drivePtr)), uintptr(unsafe.Pointer(&freeBytesAvailable)), uintptr(unsafe.Pointer(&totalBytes)), uintptr(unsafe.Pointer(&totalFreeBytes)))
if ret == 0 {
return 0, fmt.Errorf("æ— æ³•è·å–ç£ç›˜ç©ºé—´")
}
return freeBytesAvailable, nil
}
func (m *Manager) CreateISO() (string, error) {
m.log.Section("åˆ›å»ºISOé•œåƒ")
autoUnattendSrc := filepath.Join(m.config.ResourcesDir, "autounattend.xml")
autoUnattendDst := filepath.Join(m.config.Tiny11Dir, "autounattend.xml")
if utils.FileExists(autoUnattendSrc) {
m.log.Info("å¤åˆ¶æ— äººå€¼å®ˆé…ç½®æ–‡ä»¶...")
if err := utils.CopyFile(autoUnattendSrc, autoUnattendDst); err != nil {
m.log.Warn("å¤åˆ¶autounattend.xmlå¤±è´¥: %v", err)
}
} else {
m.log.Warn("æœªæ‰¾åˆ°autounattend.xml")
}
oscdimg, err := m.findOscdimg()
if err != nil {
return "", err
}
etfsboot := filepath.Join(m.config.Tiny11Dir, "boot", "etfsboot.com")
efisys := filepath.Join(m.config.Tiny11Dir, "efi", "microsoft", "boot", "efisys.bin")
if !utils.FileExists(etfsboot) {
return "", types.NewError(types.ErrCodeNotFound, "æœªæ‰¾åˆ°BIOSå¼•å¯¼æ–‡ä»¶", nil).
WithContext("path", etfsboot)
}
if !utils.FileExists(efisys) {
return "", types.NewError(types.ErrCodeNotFound, "æœªæ‰¾åˆ°UEFIå¼•å¯¼æ–‡ä»¶", nil).
WithContext("path", efisys)
}
m.log.Info("æ­£åœ¨æ„å»ºISOé•œåƒæ–‡ä»¶...")
m.log.Info("è¾“å‡ºè·¯å¾„: %s", m.config.OutputISO)
bootData := fmt.Sprintf("2#p0,e,b%s#pEF,e,b%s", etfsboot, efisys)
spinner := utils.NewSpinner("åˆ›å»ºISOé•œåƒ (è¿™å¯èƒ½éœ€è¦å‡ åˆ†é’Ÿ)")
spinner.Start()
_, err = utils.RunCommand(oscdimg, "-m", "-o", "-u2", "-udfver102", fmt.Sprintf("-bootdata:%s", bootData), m.config.Tiny11Dir, m.config.OutputISO)
spinner.Stop(err == nil)
if err != nil {
return "", types.NewError(types.ErrCodeGeneral, "åˆ›å»ºISOå¤±è´¥", err)
}
if !utils.FileExists(m.config.OutputISO) {
return "", types.NewError(types.ErrCodeGeneral, "ISOæ–‡ä»¶åˆ›å»ºåæœªæ‰¾åˆ°", nil)
}
fileInfo, _ := os.Stat(m.config.OutputISO)
if fileInfo != nil {
m.log.Success("ISOåˆ›å»ºæˆåŠŸ (å¤§å°: %s)", utils.FormatBytes(fileInfo.Size()))
} else {
m.log.Success("ISOåˆ›å»ºæˆåŠŸ")
}
return m.config.OutputISO, nil
}
func (m *Manager) findOscdimg() (string, error) {
searchPaths := []string{
filepath.Join(m.config.WorkDir, "oscdimg.exe"), filepath.Join(m.config.TempDir, "oscdimg.exe"), `C:\Program Files (x86)\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\amd64\Oscdimg\oscdimg.exe`, `C:\Program Files (x86)\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\x86\Oscdimg\oscdimg.exe`, `C:\Program Files (x86)\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\arm64\Oscdimg\oscdimg.exe`, `C:\Windows\System32\oscdimg.exe`, }
for _, path := range searchPaths {
if utils.FileExists(path) {
m.log.Info("æ‰¾åˆ° oscdimg: %s", path)
return path, nil
}
}
m.log.Info("æœªæ‰¾åˆ° oscdimg.exeï¼Œæ­£åœ¨ä»Microsoftä¸‹è½½...")
localPath := filepath.Join(m.config.TempDir, "oscdimg.exe")
url := "https://msdl.microsoft.com/download/symbols/oscdimg.exe/3D44737265000/oscdimg.exe"
spinner := utils.NewSpinner("ä¸‹è½½ oscdimg.exe")
spinner.Start()
err := utils.DownloadFile(url, localPath)
spinner.Stop(err == nil)
if err != nil {
return "", types.NewError(types.ErrCodeNetwork, "ä¸‹è½½oscdimgå¤±è´¥", err)
}
m.log.Success("oscdimg.exe ä¸‹è½½å®Œæˆ")
return localPath, nil
}
func (m *Manager) Cleanup() error {
m.log.Info("æ¸…ç†ä¸´æ—¶æ–‡ä»¶...")
cleaned := 0
errors := 0
if utils.DirExists(m.config.Tiny11Dir) {
if err := os.RemoveAll(m.config.Tiny11Dir); err != nil {
m.log.Warn("æ— æ³•åˆ é™¤tiny11ç›®å½•: %v", err)
errors++
} else {
cleaned++
}
}
if utils.DirExists(m.config.ScratchDir) {
if err := os.RemoveAll(m.config.ScratchDir); err != nil {
m.log.Warn("æ— æ³•åˆ é™¤scratchdirç›®å½•: %v", err)
errors++
} else {
cleaned++
}
}
if utils.DirExists(m.config.TempDir) {
if err := os.RemoveAll(m.config.TempDir); err != nil {
m.log.Warn("æ— æ³•åˆ é™¤tempç›®å½•: %v", err)
errors++
} else {
cleaned++
}
}
runtime.GC()
if errors > 0 {
m.log.Warn("æ¸…ç†å®Œæˆï¼Œä½†æœ‰%dä¸ªé”™è¯¯", errors)
} else {
m.log.Success("ä¸´æ—¶æ–‡ä»¶æ¸…ç†å®Œæˆ (æ¸…ç†äº†%dä¸ªé¡¹ç›®)", cleaned)
}
return nil
}
func (m *Manager) parseImageList(output string) []string {
var lines []string
outputLines := strings.Split(output, "\n")
for _, line := range outputLines {
trimmed := strings.TrimSpace(line)
if trimmed == "" {
continue
}
lines = append(lines, trimmed)
}
return lines
}
func (m *Manager) extractAvailableIndices(output string) []int {
var indices []int
lines := strings.Split(output, "\n")
for _, line := range lines {
trimmed := strings.TrimSpace(line)
if strings.HasPrefix(trimmed, "Index :") {
var index int
if _, err := fmt.Sscanf(trimmed, "Index : %d", &index); err == nil {
indices = append(indices, index)
}
}
}
return indices
}
func (m *Manager) isValidIndex(index int, availableIndices []int) bool {
for _, availIdx := range availableIndices {
if index == availIdx {
return true
}
}
return false
}
func (m *Manager) parseSizeString(sizeStr string) int64 {
sizeStr = strings.ReplaceAll(sizeStr, ",", "")
sizeStr = strings.ReplaceAll(sizeStr, " bytes", "")
sizeStr = strings.TrimSpace(sizeStr)
var size int64
fmt.Sscanf(sizeStr, "%d", &size)
return size
}
```

### 13. internal\logger\logger.go

```go
package logger
import (
"fmt"
"log"
"os"
"strings"
"time"
"tiny11-builder/internal/utils"
)
type Logger struct {
file *os.File
logger *log.Logger
}
func NewLogger(name string) *Logger {
timestamp := time.Now().Format("20060102_150405")
filename := fmt.Sprintf("%s_%s.log", name, timestamp)
logPath := "log"
if _, err := os.Stat(logPath); os.IsNotExist(err) {
os.Mkdir(logPath, 0777)
}
file, err := os.OpenFile(logPath+"/"+filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
if err != nil {
fmt.Printf("è­¦å‘Š: æ— æ³•åˆ›å»ºæ—¥å¿—æ–‡ä»¶: %v\n", err)
return &Logger{
logger: log.New(os.Stdout, "", log.LstdFlags), }
}
return &Logger{
file: file, logger: log.New(file, "", log.LstdFlags), }
}
func (l *Logger) Info(format string, args ...interface{}) {
msg := fmt.Sprintf(format, args...)
colorMsg := utils.Colorize(msg, utils.MikuWhite)
fmt.Println(colorMsg)
if l.logger != nil {
l.logger.Println(msg)
}
}
func (l *Logger) Success(format string, args ...interface{}) {
msg := fmt.Sprintf(format, args...)
colorMsg := fmt.Sprintf("%s %s", utils.Colorize("âœ“", utils.MikuGreen), utils.Colorize(msg, utils.MikuGreen), )
fmt.Println(colorMsg)
if l.logger != nil {
l.logger.Println("[SUCCESS] " + msg)
}
}
func (l *Logger) Warn(format string, args ...interface{}) {
msg := fmt.Sprintf(format, args...)
colorMsg := fmt.Sprintf("%s %s", utils.Colorize("âš ", utils.MikuYellow), utils.Colorize(msg, utils.MikuYellow), )
fmt.Println(colorMsg)
if l.logger != nil {
l.logger.Println("[WARN] " + msg)
}
}
func (l *Logger) Error(format string, args ...interface{}) {
msg := fmt.Sprintf(format, args...)
colorMsg := fmt.Sprintf("%s %s", utils.Colorize("âœ—", utils.MikuRed), utils.Colorize(msg, utils.MikuRed), )
fmt.Println(colorMsg)
if l.logger != nil {
l.logger.Println("[ERROR] " + msg)
}
}
func (l *Logger) Step(num int, desc string) {
width := utils.GetConsoleWidth()
if width > 100 {
width = 100
}
separator := strings.Repeat("â”€", width-4)
fmt.Println()
fmt.Println(utils.Colorize("â”Œ"+separator+"â”", utils.MikuCyan))
stepText := fmt.Sprintf(" [æ­¥éª¤ %d] %s ", num, desc)
padding := width - len(stepText) - 4
if padding < 0 {
padding = 0
}
fmt.Printf("%s%s%s%s\n", utils.Colorize("â”‚ ", utils.MikuCyan), utils.Colorize(fmt.Sprintf("[æ­¥éª¤ %d]", num), utils.MikuPink), utils.Colorize(" "+desc, utils.MikuCyan), utils.Colorize(strings.Repeat(" ", padding)+"â”‚", utils.MikuCyan), )
fmt.Println(utils.Colorize("â””"+separator+"â”˜", utils.MikuCyan))
if l.logger != nil {
l.logger.Printf("[STEP %d] %s", num, desc)
}
}
func (l *Logger) Header(title string) {
width := utils.GetConsoleWidth()
if width > 100 {
width = 100
}
separator := strings.Repeat("â•", width)
padding := (width - len(title)) / 2
if padding < 0 {
padding = 0
}
fmt.Println()
fmt.Println(utils.Colorize(separator, utils.MikuCyan))
fmt.Printf("%s%s%s\n", strings.Repeat(" ", padding), utils.Colorize(title, utils.MikuPink+utils.Bold), strings.Repeat(" ", padding), )
fmt.Println(utils.Colorize(separator, utils.MikuCyan))
fmt.Println()
}
func (l *Logger) Section(title string) {
fmt.Println()
fmt.Printf("%s %s\n", utils.Colorize("â–¶", utils.MikuPink), utils.Colorize(title, utils.MikuCyan+utils.Bold), )
}
func (l *Logger) Skip(format string, args ...interface{}) {
msg := fmt.Sprintf(format, args...)
colorMsg := fmt.Sprintf("%s %s", utils.Colorize("âŠ˜", utils.MikuGray), utils.Colorize(msg, utils.MikuGray), )
fmt.Println(colorMsg)
if l.logger != nil {
l.logger.Println("[SKIP] " + msg)
}
}
func (l *Logger) Close() {
if l.file != nil {
l.file.Close()
}
}
```

### 14. internal\preinstall\manager.go

```go
package preinstall
import (
"encoding/json"
"fmt"
"os"
"path/filepath"
"tiny11-builder/internal/config"
"tiny11-builder/internal/logger"
"tiny11-builder/internal/utils"
)
type Manager struct {
config *config.Config
log *logger.Logger
}
type PreinstallConfig struct {
Enabled bool `json:"enabled"`
Apps []AppPackage `json:"apps"`
}
type AppPackage struct {
ID string `json:"id"`
Name string `json:"name"`
Description string `json:"description"`
Version string `json:"version"`
Source string `json:"source"`
InstallCmd string `json:"installCmd"`
Silent bool `json:"silent"`
PostScript string `json:"postScript"`
}
func NewManager(cfg *config.Config, log *logger.Logger) *Manager {
return &Manager{
config: cfg, log: log, }
}
func (m *Manager) LoadConfig() (*PreinstallConfig, error) {
configPath := filepath.Join(m.config.PreinstallDir, "preinstall.json")
if !utils.FileExists(configPath) {
m.log.Info("é¢„è£…é…ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè·³è¿‡: %s", configPath)
return &PreinstallConfig{Enabled: false}, nil
}
data, err := os.ReadFile(configPath)
if err != nil {
m.log.Warn("æ— æ³•è¯»å–é¢„è£…é…ç½®æ–‡ä»¶: %v", err)
return &PreinstallConfig{Enabled: false}, nil
}
var cfg PreinstallConfig
if err := json.Unmarshal(data, &cfg); err != nil {
m.log.Warn("é¢„è£…é…ç½®æ–‡ä»¶æ ¼å¼é”™è¯¯: %v", err)
return &PreinstallConfig{Enabled: false}, nil
}
return &cfg, nil
}
func (m *Manager) InstallApps(selectedApps []string) error {
cfg, err := m.LoadConfig()
if err != nil {
return err
}
if !cfg.Enabled || len(cfg.Apps) == 0 {
m.log.Info("æ— é¢„è£…åº”ç”¨")
return nil
}
m.log.Section("é¢„è£…è½¯ä»¶åˆ°ç³»ç»Ÿ")
mountPath := m.config.ScratchDir
appsToInstall := m.filterApps(cfg.Apps, selectedApps)
if len(appsToInstall) == 0 {
m.log.Info("æ²¡æœ‰é€‰æ‹©è¦é¢„è£…çš„è½¯ä»¶")
return nil
}
for i, app := range appsToInstall {
m.log.Info("[%d/%d] é¢„è£…: %s v%s", i+1, len(appsToInstall), app.Name, app.Version)
srcPath := filepath.Join(m.config.PreinstallDir, app.Source)
if !utils.FileExists(srcPath) {
m.log.Warn("  âœ— å®‰è£…åŒ…ä¸å­˜åœ¨: %s", srcPath)
continue
}
if err := m.installApp(app, mountPath); err != nil {
m.log.Warn("  âœ— å®‰è£…å¤±è´¥: %v", err)
continue
}
m.log.Success("  âœ“ é…ç½®æˆåŠŸ")
}
return nil
}
func (m *Manager) filterApps(apps []AppPackage, selected []string) []AppPackage {
if len(selected) == 0 {
return []AppPackage{}
}
var filtered []AppPackage
selectedMap := make(map[string]bool)
for _, id := range selected {
selectedMap[id] = true
}
for _, app := range apps {
if selectedMap[app.ID] {
filtered = append(filtered, app)
}
}
return filtered
}
func (m *Manager) installApp(app AppPackage, mountPath string) error {
srcPath := filepath.Join(m.config.PreinstallDir, app.Source)
destDir := filepath.Join(mountPath, "Windows", "Setup", "PreInstall")
os.MkdirAll(destDir, 0755)
destPath := filepath.Join(destDir, filepath.Base(srcPath))
if err := utils.CopyFile(srcPath, destPath); err != nil {
return err
}
scriptPath := filepath.Join(mountPath, "Windows", "Setup", "Scripts", "SetupComplete.cmd")
os.MkdirAll(filepath.Dir(scriptPath), 0755)
installCmd := app.InstallCmd
if app.Silent {
installCmd += " /S /Silent"
}
script := fmt.Sprintf("@echo off\necho Installing %s...\ncd %%SystemRoot%%\\Setup\\PreInstall\n%s\n", app.Name, installCmd)
f, err := os.OpenFile(scriptPath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0755)
if err != nil {
return err
}
defer f.Close()
_, err = f.WriteString(script)
return err
}
func (m *Manager) ListAvailableApps() ([]AppPackage, error) {
cfg, err := m.LoadConfig()
if err != nil {
return nil, err
}
return cfg.Apps, nil
}
```

### 15. internal\registry\manager.go

```go
package registry
import (
"fmt"
"time"
"tiny11-builder/internal/config"
"tiny11-builder/internal/logger"
"tiny11-builder/internal/utils"
)
type Manager struct {
config *config.Config
log *logger.Logger
hivesLoaded bool
}
func NewManager(cfg *config.Config, log *logger.Logger) *Manager {
return &Manager{
config: cfg, log: log, }
}
func (m *Manager) LoadHives() error {
mountPath := m.config.ScratchDir
m.log.Info("åŠ è½½æ³¨å†Œè¡¨Hive...")
hives := map[string]string{
"HKLM\\zCOMPONENTS": "Windows\\System32\\config\\COMPONENTS", "HKLM\\zDEFAULT": "Windows\\System32\\config\\default", "HKLM\\zNTUSER": "Users\\Default\\ntuser.dat", "HKLM\\zSOFTWARE": "Windows\\System32\\config\\SOFTWARE", "HKLM\\zSYSTEM": "Windows\\System32\\config\\SYSTEM", }
for hive, path := range hives {
fullPath := fmt.Sprintf("%s\\%s", mountPath, path)
if err := loadHive(hive, fullPath); err != nil {
m.log.Warn("åŠ è½½Hiveå¤±è´¥ %s: %v", hive, err)
}
}
m.hivesLoaded = true
return nil
}
func (m *Manager) UnloadHives() error {
if !m.hivesLoaded {
return nil
}
m.log.Info("å¸è½½æ³¨å†Œè¡¨Hive...")
hives := []string{
"HKLM\\zCOMPONENTS", "HKLM\\zDEFAULT", "HKLM\\zNTUSER", "HKLM\\zSOFTWARE", "HKLM\\zSYSTEM", }
maxRetries := 3
for retry := 0; retry < maxRetries; retry++ {
if retry > 0 {
m.log.Info("ç­‰å¾…ç³»ç»Ÿé‡Šæ”¾èµ„æº...")
time.Sleep(2 * time.Second)
}
allSuccess := true
for _, hive := range hives {
if err := unloadHive(hive); err != nil {
m.log.Warn("å¸è½½Hiveå¤±è´¥ %s: %v (å°è¯• %d/%d)", hive, err, retry+1, maxRetries)
allSuccess = false
}
}
if allSuccess {
m.hivesLoaded = false
m.log.Success("æ³¨å†Œè¡¨Hiveå¸è½½æˆåŠŸ")
return nil
}
}
m.hivesLoaded = false
return fmt.Errorf("éƒ¨åˆ†æ³¨å†Œè¡¨Hiveå¸è½½å¤±è´¥")
}
func loadHive(hive, path string) error {
_, err := utils.RunCommand("reg", "load", hive, path)
return err
}
func unloadHive(hive string) error {
_, err := utils.RunCommand("reg", "unload", hive)
if err == nil {
return nil
}
utils.RunCommand("reg", "unload", hive)
time.Sleep(500 * time.Millisecond)
_, err = utils.RunCommand("reg", "unload", hive)
return err
}
```

---

> ğŸ“‹ **æç¤º**: è¿˜æœ‰ 28 ä¸ªæ–‡ä»¶æœªå±•ç¤ºï¼Œè¯·ç­‰å¾…å‘é€å®Œæ¯•åå†åˆ†æï¼
