<!--
  Generated by LLM Code Printer
  Date: 2025-11-03T17:27:52.227Z
  Part: 2 of 3
  Files: 16-30
-->

# miku-tiny11-builder (ç»­)

## ä»£ç æ–‡ä»¶ï¼ˆç»­ï¼‰

> ğŸ“Œ **è¯´æ˜**: è¿™æ˜¯ç¬¬ 2 éƒ¨åˆ†ï¼Œä»ç¬¬ 16 ä¸ªæ–‡ä»¶å¼€å§‹

> âš ï¸ **æ³¨æ„**: ä»£ç å·²ä½¿ç”¨æ ‡å‡†å‹ç¼©æ¨¡å¼ï¼Œä½¿ç”¨æ—¶è¯·å…ˆæ ¼å¼åŒ–

### 16. internal\registry\tweaks.go

```go
package registry
import (
"tiny11-builder/internal/utils"
)
func (m *Manager) ApplyTweaks() error {
m.log.Section("åº”ç”¨æ³¨å†Œè¡¨ä¼˜åŒ–")
tweaks := []struct {
desc string
fn func() error
}{ {"ç»•è¿‡ç³»ç»Ÿè¦æ±‚æ£€æŸ¥", m.bypassSystemRequirements}, {"ç¦ç”¨èµåŠ©åº”ç”¨å’Œå¹¿å‘Š", m.disableSponsoredApps}, {"å¯ç”¨æœ¬åœ°è´¦æˆ·åˆ›å»º", m.enableLocalAccounts}, {"ç¦ç”¨é¢„ç•™å­˜å‚¨ç©ºé—´", m.disableReservedStorage}, {"ç¦ç”¨BitLockerè®¾å¤‡åŠ å¯†", m.disableBitLocker}, {"ç¦ç”¨èŠå¤©å›¾æ ‡", m.disableChatIcon}, {"ç§»é™¤Edgeæ³¨å†Œè¡¨é¡¹", m.removeEdgeRegistry}, {"ç¦ç”¨OneDriveæ–‡ä»¶å¤¹å¤‡ä»½", m.disableOneDriveBackup}, {"ç¦ç”¨é¥æµ‹å’Œæ•°æ®æ”¶é›†", m.disableTelemetry}, {"é˜»æ­¢DevHomeå’ŒOutlookå®‰è£…", m.preventDevHomeOutlook}, {"ç¦ç”¨Windows Copilot", m.disableCopilot}, {"ç¦ç”¨Teamsè‡ªåŠ¨å®‰è£…", m.disableTeams}, }
success := 0
failed := 0
for i, tweak := range tweaks {
m.log.Info("[%d/%d] %s", i+1, len(tweaks), tweak.desc)
if err := tweak.fn(); err != nil {
m.log.Warn("  âœ— å¤±è´¥: %v", err)
failed++
} else {
m.log.Success("  âœ“ æˆåŠŸ")
success++
}
}
m.log.Info("")
m.log.Success("æ³¨å†Œè¡¨ä¼˜åŒ–å®Œæˆ: æˆåŠŸ %d, å¤±è´¥ %d", success, failed)
return nil
}
func (m *Manager) ApplyCoreTweaks() error {
m.log.Section("åº”ç”¨Coreç‰ˆæœ¬ç‰¹æ®Šä¼˜åŒ–")
tweaks := []struct {
desc string
fn func() error
}{ {"ç¦ç”¨Windows Defender", m.disableDefenderRegistry}, {"ç¦ç”¨Windows Update", m.disableWindowsUpdateRegistry}, {"éšè—è®¾ç½®é¡µé¢", m.hideSettingsPages}, }
success := 0
failed := 0
for i, tweak := range tweaks {
m.log.Info("[%d/%d] %s", i+1, len(tweaks), tweak.desc)
if err := tweak.fn(); err != nil {
m.log.Warn("  âœ— å¤±è´¥: %v", err)
failed++
} else {
m.log.Success("  âœ“ æˆåŠŸ")
success++
}
}
m.log.Info("")
m.log.Success("Coreä¼˜åŒ–å®Œæˆ: æˆåŠŸ %d, å¤±è´¥ %d", success, failed)
return nil
}
func (m *Manager) ApplyNanoTweaks() error {
m.log.Section("åº”ç”¨ Nano ç‰ˆæœ¬ç‰¹æ®Šä¼˜åŒ–")
tweaks := []struct {
desc string
fn func() error
}{ {"éšè— Windows Update å’Œ Defender è®¾ç½®é¡µ", m.hideNanoSettingsPages}, }
success := 0
failed := 0
for i, tweak := range tweaks {
m.log.Info("[%d/%d] %s", i+1, len(tweaks), tweak.desc)
if err := tweak.fn(); err != nil {
m.log.Warn("  âœ— å¤±è´¥: %v", err)
failed++
} else {
m.log.Success("  âœ“ æˆåŠŸ")
success++
}
}
m.log.Info("")
m.log.Success("Nano ä¼˜åŒ–å®Œæˆ: æˆåŠŸ %d, å¤±è´¥ %d", success, failed)
return nil
}
func (m *Manager) hideNanoSettingsPages() error {
sets := []regSet{ {
"HKLM\\zSOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer", "SettingsPageVisibility", "REG_SZ", "hide:virus;windowsupdate", }, }
return applyRegSets(sets)
}
func (m *Manager) ApplyBootTweaks() error {
m.log.Section("åº”ç”¨Booté•œåƒä¼˜åŒ–")
return m.bypassSystemRequirements()
}
func (m *Manager) bypassSystemRequirements() error {
sets := []regSet{ {"HKLM\\zDEFAULT\\Control Panel\\UnsupportedHardwareNotificationCache", "SV1", "REG_DWORD", "0"}, {"HKLM\\zDEFAULT\\Control Panel\\UnsupportedHardwareNotificationCache", "SV2", "REG_DWORD", "0"}, {"HKLM\\zNTUSER\\Control Panel\\UnsupportedHardwareNotificationCache", "SV1", "REG_DWORD", "0"}, {"HKLM\\zNTUSER\\Control Panel\\UnsupportedHardwareNotificationCache", "SV2", "REG_DWORD", "0"}, {"HKLM\\zSYSTEM\\Setup\\LabConfig", "BypassCPUCheck", "REG_DWORD", "1"}, {"HKLM\\zSYSTEM\\Setup\\LabConfig", "BypassRAMCheck", "REG_DWORD", "1"}, {"HKLM\\zSYSTEM\\Setup\\LabConfig", "BypassSecureBootCheck", "REG_DWORD", "1"}, {"HKLM\\zSYSTEM\\Setup\\LabConfig", "BypassStorageCheck", "REG_DWORD", "1"}, {"HKLM\\zSYSTEM\\Setup\\LabConfig", "BypassTPMCheck", "REG_DWORD", "1"}, {"HKLM\\zSYSTEM\\Setup\\MoSetup", "AllowUpgradesWithUnsupportedTPMOrCPU", "REG_DWORD", "1"}, }
return applyRegSets(sets)
}
func (m *Manager) disableSponsoredApps() error {
sets := []regSet{ {"HKLM\\zNTUSER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ContentDeliveryManager", "OemPreInstalledAppsEnabled", "REG_DWORD", "0"}, {"HKLM\\zNTUSER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ContentDeliveryManager", "PreInstalledAppsEnabled", "REG_DWORD", "0"}, {"HKLM\\zNTUSER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ContentDeliveryManager", "SilentInstalledAppsEnabled", "REG_DWORD", "0"}, {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows\\CloudContent", "DisableWindowsConsumerFeatures", "REG_DWORD", "1"}, {"HKLM\\zNTUSER\\Software\\Microsoft\\Windows\\CurrentVersion\\ContentDeliveryManager", "ContentDeliveryAllowed", "REG_DWORD", "0"}, {"HKLM\\zSOFTWARE\\Microsoft\\PolicyManager\\current\\device\\Start", "ConfigureStartPins", "REG_SZ", "{\"pinnedList\": [{}]}"}, {"HKLM\\zNTUSER\\Software\\Microsoft\\Windows\\CurrentVersion\\ContentDeliveryManager", "FeatureManagementEnabled", "REG_DWORD", "0"}, {"HKLM\\zNTUSER\\Software\\Microsoft\\Windows\\CurrentVersion\\ContentDeliveryManager", "PreInstalledAppsEverEnabled", "REG_DWORD", "0"}, {"HKLM\\zNTUSER\\Software\\Microsoft\\Windows\\CurrentVersion\\ContentDeliveryManager", "SoftLandingEnabled", "REG_DWORD", "0"}, {"HKLM\\zNTUSER\\Software\\Microsoft\\Windows\\CurrentVersion\\ContentDeliveryManager", "SubscribedContentEnabled", "REG_DWORD", "0"}, {"HKLM\\zNTUSER\\Software\\Microsoft\\Windows\\CurrentVersion\\ContentDeliveryManager", "SubscribedContent-310093Enabled", "REG_DWORD", "0"}, {"HKLM\\zNTUSER\\Software\\Microsoft\\Windows\\CurrentVersion\\ContentDeliveryManager", "SubscribedContent-338388Enabled", "REG_DWORD", "0"}, {"HKLM\\zNTUSER\\Software\\Microsoft\\Windows\\CurrentVersion\\ContentDeliveryManager", "SubscribedContent-338389Enabled", "REG_DWORD", "0"}, {"HKLM\\zNTUSER\\Software\\Microsoft\\Windows\\CurrentVersion\\ContentDeliveryManager", "SubscribedContent-338393Enabled", "REG_DWORD", "0"}, {"HKLM\\zNTUSER\\Software\\Microsoft\\Windows\\CurrentVersion\\ContentDeliveryManager", "SubscribedContent-353694Enabled", "REG_DWORD", "0"}, {"HKLM\\zNTUSER\\Software\\Microsoft\\Windows\\CurrentVersion\\ContentDeliveryManager", "SubscribedContent-353696Enabled", "REG_DWORD", "0"}, {"HKLM\\zNTUSER\\Software\\Microsoft\\Windows\\CurrentVersion\\ContentDeliveryManager", "SystemPaneSuggestionsEnabled", "REG_DWORD", "0"}, {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\PushToInstall", "DisablePushToInstall", "REG_DWORD", "1"}, {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\MRT", "DontOfferThroughWUAU", "REG_DWORD", "1"}, {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows\\CloudContent", "DisableConsumerAccountStateContent", "REG_DWORD", "1"}, {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows\\CloudContent", "DisableCloudOptimizedContent", "REG_DWORD", "1"}, }
if err := applyRegSets(sets); err != nil {
return err
}
utils.RunCommand("reg", "delete", "HKLM\\zNTUSER\\Software\\Microsoft\\Windows\\CurrentVersion\\ContentDeliveryManager\\Subscriptions", "/f")
utils.RunCommand("reg", "delete", "HKLM\\zNTUSER\\Software\\Microsoft\\Windows\\CurrentVersion\\ContentDeliveryManager\\SuggestedApps", "/f")
return nil
}
func (m *Manager) enableLocalAccounts() error {
sets := []regSet{ {"HKLM\\zSOFTWARE\\Microsoft\\Windows\\CurrentVersion\\OOBE", "BypassNRO", "REG_DWORD", "1"}, }
return applyRegSets(sets)
}
func (m *Manager) disableReservedStorage() error {
sets := []regSet{ {"HKLM\\zSOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ReserveManager", "ShippedWithReserves", "REG_DWORD", "0"}, }
return applyRegSets(sets)
}
func (m *Manager) disableBitLocker() error {
sets := []regSet{ {"HKLM\\zSYSTEM\\ControlSet001\\Control\\BitLocker", "PreventDeviceEncryption", "REG_DWORD", "1"}, }
return applyRegSets(sets)
}
func (m *Manager) disableChatIcon() error {
sets := []regSet{ {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows\\Windows Chat", "ChatIcon", "REG_DWORD", "3"}, {"HKLM\\zNTUSER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced", "TaskbarMn", "REG_DWORD", "0"}, }
return applyRegSets(sets)
}
func (m *Manager) removeEdgeRegistry() error {
utils.RunCommand("reg", "delete", "HKLM\\zSOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Microsoft Edge", "/f")
utils.RunCommand("reg", "delete", "HKLM\\zSOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Microsoft Edge Update", "/f")
return nil
}
func (m *Manager) disableOneDriveBackup() error {
sets := []regSet{ {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows\\OneDrive", "DisableFileSyncNGSC", "REG_DWORD", "1"}, }
return applyRegSets(sets)
}
func (m *Manager) disableTelemetry() error {
sets := []regSet{ {"HKLM\\zNTUSER\\Software\\Microsoft\\Windows\\CurrentVersion\\AdvertisingInfo", "Enabled", "REG_DWORD", "0"}, {"HKLM\\zNTUSER\\Software\\Microsoft\\Windows\\CurrentVersion\\Privacy", "TailoredExperiencesWithDiagnosticDataEnabled", "REG_DWORD", "0"}, {"HKLM\\zNTUSER\\Software\\Microsoft\\Speech_OneCore\\Settings\\OnlineSpeechPrivacy", "HasAccepted", "REG_DWORD", "0"}, {"HKLM\\zNTUSER\\Software\\Microsoft\\Input\\TIPC", "Enabled", "REG_DWORD", "0"}, {"HKLM\\zNTUSER\\Software\\Microsoft\\InputPersonalization", "RestrictImplicitInkCollection", "REG_DWORD", "1"}, {"HKLM\\zNTUSER\\Software\\Microsoft\\InputPersonalization", "RestrictImplicitTextCollection", "REG_DWORD", "1"}, {"HKLM\\zNTUSER\\Software\\Microsoft\\InputPersonalization\\TrainedDataStore", "HarvestContacts", "REG_DWORD", "0"}, {"HKLM\\zNTUSER\\Software\\Microsoft\\Personalization\\Settings", "AcceptedPrivacyPolicy", "REG_DWORD", "0"}, {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows\\DataCollection", "AllowTelemetry", "REG_DWORD", "0"}, {"HKLM\\zSYSTEM\\ControlSet001\\Services\\dmwappushservice", "Start", "REG_DWORD", "4"}, }
return applyRegSets(sets)
}
func (m *Manager) preventDevHomeOutlook() error {
sets := []regSet{ {"HKLM\\zSOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Orchestrator\\UScheduler\\OutlookUpdate", "workCompleted", "REG_DWORD", "1"}, {"HKLM\\zSOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Orchestrator\\UScheduler\\DevHomeUpdate", "workCompleted", "REG_DWORD", "1"}, }
if err := applyRegSets(sets); err != nil {
return err
}
utils.RunCommand("reg", "delete", "HKLM\\zSOFTWARE\\Microsoft\\WindowsUpdate\\Orchestrator\\UScheduler_Oobe\\OutlookUpdate", "/f")
utils.RunCommand("reg", "delete", "HKLM\\zSOFTWARE\\Microsoft\\WindowsUpdate\\Orchestrator\\UScheduler_Oobe\\DevHomeUpdate", "/f")
return nil
}
func (m *Manager) disableCopilot() error {
sets := []regSet{ {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows\\WindowsCopilot", "TurnOffWindowsCopilot", "REG_DWORD", "1"}, {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Edge", "HubsSidebarEnabled", "REG_DWORD", "0"}, {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows\\Explorer", "DisableSearchBoxSuggestions", "REG_DWORD", "1"}, }
return applyRegSets(sets)
}
func (m *Manager) disableTeams() error {
sets := []regSet{ {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Teams", "DisableInstallation", "REG_DWORD", "1"}, {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows\\Windows Mail", "PreventRun", "REG_DWORD", "1"}, }
return applyRegSets(sets)
}
func (m *Manager) disableDefenderRegistry() error {
services := []string{
"WinDefend", "WdNisSvc", "WdNisDrv", "WdFilter", "Sense", }
for _, service := range services {
path := "HKLM\\zSYSTEM\\ControlSet001\\Services\\" + service
utils.RunCommand("reg", "add", path, "/v", "Start", "/t", "REG_DWORD", "/d", "4", "/f")
}
sets := []regSet{ {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows Defender", "DisableAntiSpyware", "REG_DWORD", "1"}, {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time Protection", "DisableRealtimeMonitoring", "REG_DWORD", "1"}, {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time Protection", "DisableBehaviorMonitoring", "REG_DWORD", "1"}, {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time Protection", "DisableOnAccessProtection", "REG_DWORD", "1"}, {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time Protection", "DisableScanOnRealtimeEnable", "REG_DWORD", "1"}, }
return applyRegSets(sets)
}
func (m *Manager) disableWindowsUpdateRegistry() error {
sets := []regSet{ {"HKLM\\zSYSTEM\\ControlSet001\\Services\\wuauserv", "Start", "REG_DWORD", "4"}, {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate", "DoNotConnectToWindowsUpdateInternetLocations", "REG_DWORD", "1"}, {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate", "DisableWindowsUpdateAccess", "REG_DWORD", "1"}, {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate", "WUServer", "REG_SZ", "localhost"}, {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate", "WUStatusServer", "REG_SZ", "localhost"}, {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate", "UpdateServiceUrlAlternate", "REG_SZ", "localhost"}, {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU", "UseWUServer", "REG_DWORD", "1"}, {"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU", "NoAutoUpdate", "REG_DWORD", "1"}, {"HKLM\\zSOFTWARE\\Microsoft\\Windows\\CurrentVersion\\OOBE", "DisableOnline", "REG_DWORD", "1"}, }
if err := applyRegSets(sets); err != nil {
return err
}
utils.RunCommand("reg", "delete", "HKLM\\zSYSTEM\\ControlSet001\\Services\\WaaSMedicSVC", "/f")
utils.RunCommand("reg", "delete", "HKLM\\zSYSTEM\\ControlSet001\\Services\\UsoSvc", "/f")
utils.RunCommand("reg", "add", "HKLM\\zSOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce", "/v", "StopWUPostOOBE1", "/t", "REG_SZ", "/d", "net stop wuauserv", "/f")
utils.RunCommand("reg", "add", "HKLM\\zSOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce", "/v", "StopWUPostOOBE2", "/t", "REG_SZ", "/d", "sc stop wuauserv", "/f")
utils.RunCommand("reg", "add", "HKLM\\zSOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce", "/v", "StopWUPostOOBE3", "/t", "REG_SZ", "/d", "sc config wuauserv start= disabled", "/f")
return nil
}
func (m *Manager) hideSettingsPages() error {
sets := []regSet{ {"HKLM\\zSOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer", "SettingsPageVisibility", "REG_SZ", "hide:virus;windowsupdate"}, }
return applyRegSets(sets)
}
type regSet struct {
path string
name string
typ string
value string
}
func applyRegSets(sets []regSet) error {
for _, set := range sets {
_, err := utils.RunCommand("reg", "add", set.path, "/v", set.name, "/t", set.typ, "/d", set.value, "/f")
if err != nil {
continue
}
}
return nil
}
func (m *Manager) hideWindowsUpdatePage() error {
sets := []regSet{ {"HKLM\\zSOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer", "SettingsPageVisibility", "REG_SZ", "hide:virus;windowsupdate"}, }
return applyRegSets(sets)
}
func (m *Manager) hideVirusProtectionPage() error {
return nil
}
```

### 17. internal\remover\apps.go

```go
package remover
import (
"fmt"
"strings"
"tiny11-builder/internal/config"
"tiny11-builder/internal/logger"
"tiny11-builder/internal/utils"
)
type AppRemover struct {
config *config.Config
log *logger.Logger
}
func NewAppRemover(cfg *config.Config, log *logger.Logger) *AppRemover {
return &AppRemover{
config: cfg, log: log, }
}
func (r *AppRemover) RemoveProvisionedApps() error {
mountPath := r.config.ScratchDir
r.log.Section("ç§»é™¤é¢„è£…åº”ç”¨")
spinner := utils.NewSpinner("æ‰«æå·²å®‰è£…çš„åº”ç”¨åŒ…...")
spinner.Start()
output, err := utils.RunCommand("dism", "/English", fmt.Sprintf("/Image:%s", mountPath), "/Get-ProvisionedAppxPackages")
spinner.Stop(err == nil)
if err != nil {
return fmt.Errorf("è·å–åº”ç”¨åˆ—è¡¨å¤±è´¥: %w", err)
}
packages := r.parsePackageNames(output)
r.log.Info("å‘ç° %d ä¸ªé¢„è£…åº”ç”¨åŒ…", len(packages))
appPrefixes := r.getRemovalList()
packagesToRemove := r.matchPackages(packages, appPrefixes)
if len(packagesToRemove) == 0 {
r.log.Info("æ²¡æœ‰éœ€è¦ç§»é™¤çš„åº”ç”¨åŒ…")
return nil
}
r.log.Info("å‡†å¤‡ç§»é™¤ %d ä¸ªåº”ç”¨åŒ…", len(packagesToRemove))
removed := 0
failed := 0
for i, pkg := range packagesToRemove {
pkgName := r.extractShortName(pkg)
r.log.Info("[%d/%d] ç§»é™¤: %s", i+1, len(packagesToRemove), utils.Colorize(pkgName, utils.MikuYellow))
_, err := utils.RunCommand("dism", "/English", fmt.Sprintf("/Image:%s", mountPath), "/Remove-ProvisionedAppxPackage", fmt.Sprintf("/PackageName:%s", pkg))
if err != nil {
r.log.Warn("  âœ— ç§»é™¤å¤±è´¥: %v", err)
failed++
} else {
r.log.Success("  âœ“ ç§»é™¤æˆåŠŸ")
removed++
}
}
r.log.Info("")
r.log.Success("åº”ç”¨ç§»é™¤å®Œæˆ: æˆåŠŸ %d, å¤±è´¥ %d", removed, failed)
return nil
}
func (r *AppRemover) getRemovalList() []string {
return []string{
"AppUp.IntelManagementandSecurityStatus", "Clipchamp.Clipchamp", "DolbyLaboratories.DolbyAccess", "DolbyLaboratories.DolbyDigitalPlusDecoderOEM", "Microsoft.BingNews", "Microsoft.BingSearch", "Microsoft.BingWeather", "Microsoft.Copilot", "Microsoft.Windows.CrossDevice", "Microsoft.GamingApp", "Microsoft.GetHelp", "Microsoft.Getstarted", "Microsoft.Microsoft3DViewer", "Microsoft.MicrosoftOfficeHub", "Microsoft.MicrosoftSolitaireCollection", "Microsoft.MicrosoftStickyNotes", "Microsoft.MixedReality.Portal", "Microsoft.MSPaint", "Microsoft.Office.OneNote", "Microsoft.OfficePushNotificationUtility", "Microsoft.OutlookForWindows", "Microsoft.Paint", "Microsoft.People", "Microsoft.PowerAutomateDesktop", "Microsoft.SkypeApp", "Microsoft.StartExperiencesApp", "Microsoft.Todos", "Microsoft.Wallet", "Microsoft.Windows.DevHome", "Microsoft.Windows.Copilot", "Microsoft.Windows.Teams", "Microsoft.WindowsAlarms", "Microsoft.WindowsCamera", "microsoft.windowscommunicationsapps", "Microsoft.WindowsFeedbackHub", "Microsoft.WindowsMaps", "Microsoft.WindowsSoundRecorder", "Microsoft.WindowsTerminal", "Microsoft.Xbox.TCUI", "Microsoft.XboxApp", "Microsoft.XboxGameOverlay", "Microsoft.XboxGamingOverlay", "Microsoft.XboxIdentityProvider", "Microsoft.XboxSpeechToTextOverlay", "Microsoft.YourPhone", "Microsoft.ZuneMusic", "Microsoft.ZuneVideo", "MicrosoftCorporationII.MicrosoftFamily", "MicrosoftCorporationII.QuickAssist", "MSTeams", "MicrosoftTeams", "Microsoft.WindowsTerminal", "Microsoft.549981C3F5F10", }
}
func (r *AppRemover) parsePackageNames(output string) []string {
var packages []string
lines := strings.Split(output, "\n")
for _, line := range lines {
trimmed := strings.TrimSpace(line)
if strings.HasPrefix(trimmed, "PackageName :") {
pkgName := strings.TrimSpace(strings.TrimPrefix(trimmed, "PackageName :"))
if pkgName != "" && !strings.Contains(pkgName, "...") {
packages = append(packages, pkgName)
}
}
}
return packages
}
func (r *AppRemover) matchPackages(packages []string, prefixes []string) []string {
var matched []string
for _, pkg := range packages {
for _, prefix := range prefixes {
if strings.Contains(pkg, prefix) {
matched = append(matched, pkg)
break
}
}
}
return matched
}
func (r *AppRemover) extractShortName(fullName string) string {
parts := strings.Split(fullName, "_")
if len(parts) > 0 {
return parts[0]
}
return fullName
}
func (r *AppRemover) RemoveSystemPackages(languageCode string) error {
mountPath := r.config.ScratchDir
r.log.Section("ç§»é™¤ç³»ç»Ÿç»„ä»¶åŒ…")
output, err := utils.RunCommand("dism", fmt.Sprintf("/Image:%s", mountPath), "/Get-Packages", "/Format:Table")
if err != nil {
return fmt.Errorf("è·å–ç³»ç»ŸåŒ…åˆ—è¡¨å¤±è´¥: %w", err)
}
packagePatterns := r.getSystemPackagePatterns(languageCode)
removed := 0
failed := 0
for i, pattern := range packagePatterns {
r.log.Info("[%d/%d] æ£€æŸ¥åŒ…: %s", i+1, len(packagePatterns), utils.Colorize(pattern, utils.MikuYellow))
packages := r.findMatchingPackages(output, pattern)
if len(packages) == 0 {
r.log.Info("  æœªæ‰¾åˆ°åŒ¹é…çš„åŒ…")
continue
}
for _, pkg := range packages {
r.log.Info("  ç§»é™¤: %s", pkg)
_, err := utils.RunCommand("dism", fmt.Sprintf("/Image:%s", mountPath), "/Remove-Package", fmt.Sprintf("/PackageName:%s", pkg))
if err != nil {
r.log.Warn("  âœ— ç§»é™¤å¤±è´¥: %v", err)
failed++
} else {
r.log.Success("  âœ“ ç§»é™¤æˆåŠŸ")
removed++
}
}
}
r.log.Info("")
r.log.Success("ç³»ç»ŸåŒ…ç§»é™¤å®Œæˆ: æˆåŠŸ %d, å¤±è´¥ %d", removed, failed)
return nil
}
func (r *AppRemover) getSystemPackagePatterns(languageCode string) []string {
return []string{
"Microsoft-Windows-InternetExplorer-Optional-Package~31bf3856ad364e35", "Microsoft-Windows-Kernel-LA57-FoD-Package~31bf3856ad364e35~amd64", fmt.Sprintf("Microsoft-Windows-LanguageFeatures-Handwriting-%s-Package~31bf3856ad364e35", languageCode), fmt.Sprintf("Microsoft-Windows-LanguageFeatures-OCR-%s-Package~31bf3856ad364e35", languageCode), fmt.Sprintf("Microsoft-Windows-LanguageFeatures-Speech-%s-Package~31bf3856ad364e35", languageCode), fmt.Sprintf("Microsoft-Windows-LanguageFeatures-TextToSpeech-%s-Package~31bf3856ad364e35", languageCode), "Microsoft-Windows-MediaPlayer-Package~31bf3856ad364e35", "Microsoft-Windows-Wallpaper-Content-Extended-FoD-Package~31bf3856ad364e35", "Windows-Defender-Client-Package~31bf3856ad364e35~", "Microsoft-Windows-WordPad-FoD-Package~", "Microsoft-Windows-TabletPCMath-Package~", "Microsoft-Windows-StepsRecorder-Package~", }
}
func (r *AppRemover) findMatchingPackages(output, pattern string) []string {
var matches []string
lines := strings.Split(output, "\n")
for _, line := range lines {
trimmed := strings.TrimSpace(line)
if strings.Contains(trimmed, pattern) {
fields := strings.Fields(trimmed)
if len(fields) > 0 {
matches = append(matches, fields[0])
}
}
}
return matches
}
```

### 18. internal\remover\core.go

```go
package remover
import (
"fmt"
"io"
"os"
"path/filepath"
"tiny11-builder/internal/config"
"tiny11-builder/internal/logger"
"tiny11-builder/internal/utils"
)
type CoreRemover struct {
config *config.Config
log *logger.Logger
}
func NewCoreRemover(cfg *config.Config, log *logger.Logger) *CoreRemover {
return &CoreRemover{
config: cfg, log: log, }
}
func (r *CoreRemover) RemoveWinSxS() error {
mountPath := r.config.ScratchDir
winsxsPath := filepath.Join(mountPath, "Windows", "WinSxS")
winsxsEditPath := filepath.Join(mountPath, "Windows", "WinSxS_edit")
r.log.Section("å¤„ç†WinSxSç»„ä»¶å­˜å‚¨")
r.log.Warn("è¿™å°†ç§»é™¤å¤§éƒ¨åˆ†WinSxSå†…å®¹ï¼Œå¯èƒ½éœ€è¦30-60åˆ†é’Ÿ")
if !utils.DirExists(winsxsPath) {
return fmt.Errorf("WinSxSç›®å½•ä¸å­˜åœ¨: %s", winsxsPath)
}
spinner := utils.NewSpinner("è®¡ç®—WinSxSå¤§å°...")
spinner.Start()
originalSize, _ := r.getDirSize(winsxsPath)
spinner.Stop(true)
r.log.Info("åŸå§‹WinSxSå¤§å°: %s", utils.FormatBytes(originalSize))
r.log.Info("åˆ›å»ºä¸´æ—¶å·¥ä½œç›®å½•...")
if err := os.MkdirAll(winsxsEditPath, 0755); err != nil {
return fmt.Errorf("åˆ›å»ºå·¥ä½œç›®å½•å¤±è´¥: %w", err)
}
keepDirs := r.getKeepDirs()
r.log.Info("å°†ä¿ç•™ %d ç±»å¿…è¦ç»„ä»¶", len(keepDirs))
totalCopied := 0
totalFailed := 0
for i, pattern := range keepDirs {
r.log.Info("[%d/%d] ä¿ç•™ç»„ä»¶: %s", i+1, len(keepDirs), utils.Colorize(pattern, utils.MikuYellow))
matches, err := filepath.Glob(filepath.Join(winsxsPath, pattern))
if err != nil {
r.log.Warn("  æ‰«æå¤±è´¥: %v", err)
continue
}
if len(matches) == 0 {
r.log.Info("  æœªæ‰¾åˆ°åŒ¹é…é¡¹")
continue
}
for _, match := range matches {
relPath, _ := filepath.Rel(winsxsPath, match)
destPath := filepath.Join(winsxsEditPath, relPath)
info, err := os.Stat(match)
if err != nil {
continue
}
if info.IsDir() {
err = r.copyDirQuiet(match, destPath)
} else {
err = r.copyFileQuiet(match, destPath)
}
if err != nil {
totalFailed++
} else {
totalCopied++
}
}
}
r.log.Success("  âœ“ å¤åˆ¶å®Œæˆ: æˆåŠŸ %d, å¤±è´¥ %d", totalCopied, totalFailed)
r.log.Info("è·å–WinSxSæ‰€æœ‰æƒ...")
spinner = utils.NewSpinner("è·å–ç›®å½•æ‰€æœ‰æƒ (è¿™å¯èƒ½éœ€è¦å‡ åˆ†é’Ÿ)...")
spinner.Start()
if err := utils.TakeownRecursive(winsxsPath); err != nil {
spinner.Stop(false)
r.log.Warn("è·å–æ‰€æœ‰æƒå¤±è´¥: %v", err)
} else {
spinner.Stop(true)
}
r.log.Info("è®¾ç½®ç›®å½•æƒé™...")
spinner = utils.NewSpinner("è®¾ç½®å®Œå…¨æ§åˆ¶æƒé™...")
spinner.Start()
if err := utils.GrantPermissionRecursive(winsxsPath); err != nil {
spinner.Stop(false)
r.log.Warn("è®¾ç½®æƒé™å¤±è´¥: %v", err)
} else {
spinner.Stop(true)
}
r.log.Info("åˆ é™¤åŸå§‹WinSxSç›®å½•...")
spinner = utils.NewSpinner("åˆ é™¤WinSxS (è¿™å¯èƒ½éœ€è¦10-20åˆ†é’Ÿ)...")
spinner.Start()
if err := os.RemoveAll(winsxsPath); err != nil {
spinner.Stop(false)
return fmt.Errorf("åˆ é™¤WinSxSå¤±è´¥: %w", err)
}
spinner.Stop(true)
r.log.Info("åº”ç”¨ç²¾ç®€åçš„WinSxS...")
if err := os.Rename(winsxsEditPath, winsxsPath); err != nil {
return fmt.Errorf("é‡å‘½åå¤±è´¥: %w", err)
}
newSize, _ := r.getDirSize(winsxsPath)
saved := originalSize - newSize
r.log.Success("WinSxSç²¾ç®€å®Œæˆ")
r.log.Info("  åŸå§‹å¤§å°: %s", utils.FormatBytes(originalSize))
r.log.Info("  æ–°å¤§å°:   %s", utils.FormatBytes(newSize))
r.log.Info("  èŠ‚çœ:     %s (%.1f%%)", utils.FormatBytes(saved), float64(saved)/float64(originalSize)*100)
return nil
}
func (r *CoreRemover) getKeepDirs() []string {
arch := r.config.GetArchitecture()
common := []string{
"Catalogs", "FileMaps", "Fusion", "InstallTemp", "Manifests", }
var archSpecific []string
if arch == "amd64" {
archSpecific = []string{
"x86_microsoft.windows.common-controls_6595b64144ccf1df_*", "x86_microsoft.windows.gdiplus_6595b64144ccf1df_*", "x86_microsoft.windows.i..utomation.proxystub_6595b64144ccf1df_*", "x86_microsoft.windows.isolationautomation_6595b64144ccf1df_*", "x86_microsoft-windows-s..ngstack-onecorebase_31bf3856ad364e35_*", "x86_microsoft-windows-s..stack-termsrv-extra_31bf3856ad364e35_*", "x86_microsoft-windows-servicingstack_31bf3856ad364e35_*", "x86_microsoft-windows-servicingstack-inetsrv_*", "x86_microsoft-windows-servicingstack-onecore_*", "x86_microsoft.vc80.crt_1fc8b3b9a1e18e3b_*", "x86_microsoft.vc90.crt_1fc8b3b9a1e18e3b_*", "x86_microsoft.windows.c..-controls.resources_6595b64144ccf1df_*", "amd64_microsoft.vc80.crt_1fc8b3b9a1e18e3b_*", "amd64_microsoft.vc90.crt_1fc8b3b9a1e18e3b_*", "amd64_microsoft.windows.c..-controls.resources_6595b64144ccf1df_*", "amd64_microsoft.windows.common-controls_6595b64144ccf1df_*", "amd64_microsoft.windows.gdiplus_6595b64144ccf1df_*", "amd64_microsoft.windows.i..utomation.proxystub_6595b64144ccf1df_*", "amd64_microsoft.windows.isolationautomation_6595b64144ccf1df_*", "amd64_microsoft-windows-s..stack-inetsrv-extra_31bf3856ad364e35_*", "amd64_microsoft-windows-s..stack-msg.resources_31bf3856ad364e35_*", "amd64_microsoft-windows-s..stack-termsrv-extra_31bf3856ad364e35_*", "amd64_microsoft-windows-servicingstack_31bf3856ad364e35_*", "amd64_microsoft-windows-servicingstack-inetsrv_31bf3856ad364e35_*", "amd64_microsoft-windows-servicingstack-msg_31bf3856ad364e35_*", "amd64_microsoft-windows-servicingstack-onecore_31bf3856ad364e35_*", }
} else if arch == "arm64" {
archSpecific = []string{
"x86_microsoft.vc80.crt_1fc8b3b9a1e18e3b_*", "x86_microsoft.vc90.crt_1fc8b3b9a1e18e3b_*", "x86_microsoft.windows.c..-controls.resources_6595b64144ccf1df_*", "x86_microsoft.windows.common-controls_6595b64144ccf1df_*", "x86_microsoft.windows.gdiplus_6595b64144ccf1df_*", "x86_microsoft.windows.i..utomation.proxystub_6595b64144ccf1df_*", "x86_microsoft.windows.isolationautomation_6595b64144ccf1df_*", "arm_microsoft.windows.c..-controls.resources_6595b64144ccf1df_*", "arm_microsoft.windows.common-controls_6595b64144ccf1df_*", "arm_microsoft.windows.gdiplus_6595b64144ccf1df_*", "arm_microsoft.windows.i..utomation.proxystub_6595b64144ccf1df_*", "arm_microsoft.windows.isolationautomation_6595b64144ccf1df_*", "arm64_microsoft.vc80.crt_1fc8b3b9a1e18e3b_*", "arm64_microsoft.vc90.crt_1fc8b3b9a1e18e3b_*", "arm64_microsoft.windows.c..-controls.resources_6595b64144ccf1df_*", "arm64_microsoft.windows.common-controls_6595b64144ccf1df_*", "arm64_microsoft.windows.gdiplus_6595b64144ccf1df_*", "arm64_microsoft.windows.i..utomation.proxystub_6595b64144ccf1df_*", "arm64_microsoft.windows.isolationautomation_6595b64144ccf1df_*", "arm64_microsoft-windows-servicing-adm_31bf3856ad364e35_*", "arm64_microsoft-windows-servicingcommon_31bf3856ad364e35_*", "arm64_microsoft-windows-servicing-onecore-uapi_31bf3856ad364e35_*", "arm64_microsoft-windows-servicingstack_31bf3856ad364e35_*", "arm64_microsoft-windows-servicingstack-inetsrv_31bf3856ad364e35_*", "arm64_microsoft-windows-servicingstack-msg_31bf3856ad364e35_*", "arm64_microsoft-windows-servicingstack-onecore_31bf3856ad364e35_*", }
}
return append(common, archSpecific...)
}
func (r *CoreRemover) copyDirQuiet(src, dst string) error {
return filepath.Walk(src, func(path string, info os.FileInfo, err error) error {
if err != nil {
return nil
}
relPath, _ := filepath.Rel(src, path)
targetPath := filepath.Join(dst, relPath)
if info.IsDir() {
return os.MkdirAll(targetPath, info.Mode())
}
return r.copyFileQuiet(path, targetPath)
})
}
func (r *CoreRemover) copyFileQuiet(src, dst string) error {
sourceFile, err := os.Open(src)
if err != nil {
return err
}
defer sourceFile.Close()
os.MkdirAll(filepath.Dir(dst), 0755)
destFile, err := os.Create(dst)
if err != nil {
return err
}
defer destFile.Close()
_, err = io.Copy(destFile, sourceFile)
return err
}
func (r *CoreRemover) getDirSize(path string) (int64, error) {
var size int64
err := filepath.Walk(path, func(_ string, info os.FileInfo, err error) error {
if err != nil {
return nil
}
if !info.IsDir() {
size += info.Size()
}
return nil
})
return size, err
}
func (r *CoreRemover) DisableDefender() error {
r.log.Section("ç¦ç”¨Windows Defender")
r.log.Info("Defenderå°†é€šè¿‡æ³¨å†Œè¡¨ç¦ç”¨")
return nil
}
func (r *CoreRemover) DisableWindowsUpdate() error {
r.log.Section("ç¦ç”¨Windows Update")
r.log.Info("Windows Updateå°†é€šè¿‡æ³¨å†Œè¡¨ç¦ç”¨")
return nil
}
func (r *CoreRemover) RemoveWinRE() error {
mountPath := r.config.ScratchDir
recoveryPath := filepath.Join(mountPath, "Windows", "System32", "Recovery")
winrePath := filepath.Join(recoveryPath, "winre.wim")
r.log.Section("ç§»é™¤WinREæ¢å¤ç¯å¢ƒ")
if !utils.FileExists(winrePath) {
r.log.Info("winre.wim ä¸å­˜åœ¨ï¼Œè·³è¿‡")
return nil
}
utils.TakeownRecursive(recoveryPath)
utils.GrantPermissionRecursive(recoveryPath)
if err := os.Remove(winrePath); err != nil {
r.log.Warn("åˆ é™¤winre.wimå¤±è´¥: %v", err)
} else {
r.log.Success("âœ“ winre.wimå·²åˆ é™¤")
}
f, err := os.Create(winrePath)
if err == nil {
f.Close()
r.log.Info("å·²åˆ›å»ºç©ºå ä½æ–‡ä»¶")
}
r.log.Success("WinREç§»é™¤å®Œæˆ")
return nil
}
```

### 19. internal\remover\edge.go

```go
package remover
import (
"fmt"
"os"
"path/filepath"
"tiny11-builder/internal/utils"
)
func (r *AppRemover) RemoveEdge() error {
mountPath := r.config.ScratchDir
r.log.Section("ç§»é™¤Microsoft Edge")
removed := 0
failed := 0
edgePaths := []struct {
path string
desc string
}{ {filepath.Join(mountPath, "Program Files (x86)", "Microsoft", "Edge"), "Edgeä¸»ç¨‹åº"}, {filepath.Join(mountPath, "Program Files (x86)", "Microsoft", "EdgeUpdate"), "Edgeæ›´æ–°ç¨‹åº"}, {filepath.Join(mountPath, "Program Files (x86)", "Microsoft", "EdgeCore"), "Edgeæ ¸å¿ƒç»„ä»¶"}, }
for _, item := range edgePaths {
if utils.DirExists(item.path) {
r.log.Info("ç§»é™¤: %s", item.desc)
if err := os.RemoveAll(item.path); err != nil {
r.log.Warn("  âœ— å¤±è´¥: %v", err)
failed++
} else {
r.log.Success("  âœ“ æˆåŠŸ")
removed++
}
}
}
webviewPath := filepath.Join(mountPath, "Windows", "System32", "Microsoft-Edge-Webview")
if utils.DirExists(webviewPath) {
r.log.Info("ç§»é™¤Edge WebView...")
if err := utils.TakeownRecursive(webviewPath); err != nil {
r.log.Warn("  è·å–æ‰€æœ‰æƒå¤±è´¥: %v", err)
}
if err := utils.GrantPermissionRecursive(webviewPath); err != nil {
r.log.Warn("  è®¾ç½®æƒé™å¤±è´¥: %v", err)
}
if err := os.RemoveAll(webviewPath); err != nil {
r.log.Warn("  âœ— åˆ é™¤å¤±è´¥: %v", err)
failed++
} else {
r.log.Success("  âœ“ åˆ é™¤æˆåŠŸ")
removed++
}
}
r.removeEdgeFromWinSxS(mountPath, &removed, &failed)
r.log.Info("")
r.log.Success("Edgeç§»é™¤å®Œæˆ: æˆåŠŸ %d, å¤±è´¥ %d", removed, failed)
return nil
}
func (r *AppRemover) removeEdgeFromWinSxS(mountPath string, removed, failed *int) {
winsxsPath := filepath.Join(mountPath, "Windows", "WinSxS")
arch := r.config.GetArchitecture()
pattern := fmt.Sprintf("%s_microsoft-edge-webview_*", arch)
r.log.Info("æ‰«æWinSxSä¸­çš„Edgeç»„ä»¶ (æ¨¡å¼: %s)...", pattern)
matches, err := filepath.Glob(filepath.Join(winsxsPath, pattern))
if err != nil {
r.log.Warn("  æ‰«æå¤±è´¥: %v", err)
return
}
if len(matches) == 0 {
r.log.Info("  æœªæ‰¾åˆ°Edgeç»„ä»¶")
return
}
for _, match := range matches {
dirName := filepath.Base(match)
r.log.Info("  ç§»é™¤WinSxS: %s", dirName)
if err := utils.TakeownRecursive(match); err != nil {
r.log.Warn("    è·å–æ‰€æœ‰æƒå¤±è´¥: %v", err)
}
if err := utils.GrantPermissionRecursive(match); err != nil {
r.log.Warn("    è®¾ç½®æƒé™å¤±è´¥: %v", err)
}
if err := os.RemoveAll(match); err != nil {
r.log.Warn("    âœ— åˆ é™¤å¤±è´¥: %v", err)
(*failed)++
} else {
r.log.Success("    âœ“ åˆ é™¤æˆåŠŸ")
(*removed)++
}
}
}
func (r *AppRemover) RemoveOneDrive() error {
mountPath := r.config.ScratchDir
r.log.Section("ç§»é™¤OneDrive")
onedrivePath := filepath.Join(mountPath, "Windows", "System32", "OneDriveSetup.exe")
if !utils.FileExists(onedrivePath) {
r.log.Info("OneDriveSetup.exe ä¸å­˜åœ¨ï¼Œè·³è¿‡")
return nil
}
if err := utils.Takeown(onedrivePath); err != nil {
r.log.Warn("è·å–æ‰€æœ‰æƒå¤±è´¥: %v", err)
}
if err := utils.GrantPermission(onedrivePath); err != nil {
r.log.Warn("è®¾ç½®æƒé™å¤±è´¥: %v", err)
}
if err := os.Remove(onedrivePath); err != nil {
r.log.Warn("âœ— åˆ é™¤å¤±è´¥: %v", err)
return err
}
r.log.Success("âœ“ OneDriveç§»é™¤æˆåŠŸ")
return nil
}
func (r *AppRemover) RemoveScheduledTasks() error {
mountPath := r.config.ScratchDir
tasksPath := filepath.Join(mountPath, "Windows", "System32", "Tasks")
r.log.Section("ç§»é™¤é¥æµ‹è®¡åˆ’ä»»åŠ¡")
tasks := []struct {
path string
desc string
}{ {
filepath.Join(tasksPath, "Microsoft", "Windows", "Application Experience", "Microsoft Compatibility Appraiser"), "åº”ç”¨å…¼å®¹æ€§è¯„ä¼°", }, {
filepath.Join(tasksPath, "Microsoft", "Windows", "Application Experience", "ProgramDataUpdater"), "ç¨‹åºæ•°æ®æ›´æ–°", }, {
filepath.Join(tasksPath, "Microsoft", "Windows", "Customer Experience Improvement Program"), "å®¢æˆ·ä½“éªŒæ”¹å–„è®¡åˆ’(æ•´ä¸ªæ–‡ä»¶å¤¹)", }, {
filepath.Join(tasksPath, "Microsoft", "Windows", "Chkdsk", "Proxy"), "ç£ç›˜æ£€æŸ¥ä»£ç†", }, {
filepath.Join(tasksPath, "Microsoft", "Windows", "Windows Error Reporting", "QueueReporting"), "é”™è¯¯æŠ¥å‘Šé˜Ÿåˆ—", }, }
removed := 0
failed := 0
for _, task := range tasks {
r.log.Info("åˆ é™¤: %s", task.desc)
var err error
info, statErr := os.Stat(task.path)
if os.IsNotExist(statErr) {
r.log.Info("  ä¸å­˜åœ¨ï¼Œè·³è¿‡")
continue
}
if statErr == nil && info.IsDir() {
err = os.RemoveAll(task.path)
} else {
err = os.Remove(task.path)
}
if err != nil {
r.log.Warn("  âœ— åˆ é™¤å¤±è´¥: %v", err)
failed++
} else {
r.log.Success("  âœ“ åˆ é™¤æˆåŠŸ")
removed++
}
}
r.log.Info("")
r.log.Success("è®¡åˆ’ä»»åŠ¡ç§»é™¤å®Œæˆ: æˆåŠŸ %d, å¤±è´¥ %d", removed, failed)
return nil
}
```

### 20. internal\remover\nano.go

```go
package remover
import (
"fmt"
"os"
"path/filepath"
"strings"
"tiny11-builder/internal/config"
"tiny11-builder/internal/logger"
"tiny11-builder/internal/utils"
)
type NanoRemover struct {
config *config.Config
log *logger.Logger
}
func NewNanoRemover(cfg *config.Config, log *logger.Logger) *NanoRemover {
return &NanoRemover{
config: cfg, log: log, }
}
func (r *NanoRemover) RemoveAggressiveApps() error {
mountPath := r.config.ScratchDir
r.log.Section("ç§»é™¤æ‰©å±•åº”ç”¨åˆ—è¡¨ (Nanoæ¨¡å¼)")
extraPatterns := []string{
"*Photos*", "*Camera*", "*Paint*", "*Notepad*", "*QuickAssist*", "*CoreAI*", "*PeopleExperienceHost*", "*PinningConfirmationDialog*", "*SecureAssessmentBrowser*", "*AV1VideoExtension*", "*AVCEncoderVideoExtension*", "*HEIFImageExtension*", "*HEVCVideoExtension*", "*RawImageExtension*", "*VP9VideoExtensions*", "*WebpImageExtension*", "*SecHealthUI*", "*CompatibilityEnhancements*", }
spinner := utils.NewSpinner("è·å–å·²å®‰è£…çš„åº”ç”¨åŒ…...")
spinner.Start()
output, err := utils.RunCommand("dism", "/English", fmt.Sprintf("/Image:%s", mountPath), "/Get-ProvisionedAppxPackages")
spinner.Stop(err == nil)
if err != nil {
return fmt.Errorf("è·å–åº”ç”¨åˆ—è¡¨å¤±è´¥: %w", err)
}
var packages []string
lines := strings.Split(output, "\n")
for _, line := range lines {
trimmed := strings.TrimSpace(line)
if strings.HasPrefix(trimmed, "PackageName :") {
pkgName := strings.TrimSpace(strings.TrimPrefix(trimmed, "PackageName :"))
if pkgName != "" {
packages = append(packages, pkgName)
}
}
}
r.log.Info("å‘ç° %d ä¸ªå·²å®‰è£…çš„åº”ç”¨åŒ…", len(packages))
removed := 0
failed := 0
for i, pattern := range extraPatterns {
r.log.Info("[%d/%d] æ£€æŸ¥åº”ç”¨æ¨¡å¼: %s", i+1, len(extraPatterns), utils.Colorize(pattern, utils.MikuYellow))
cleanPattern := strings.Trim(pattern, "*")
found := false
for _, pkg := range packages {
if strings.Contains(strings.ToLower(pkg), strings.ToLower(cleanPattern)) {
found = true
r.log.Info("  ç§»é™¤: %s", pkg)
_, err := utils.RunCommand("dism", "/English", fmt.Sprintf("/Image:%s", mountPath), "/Remove-ProvisionedAppxPackage", fmt.Sprintf("/PackageName:%s", pkg))
if err != nil {
r.log.Warn("  âœ— å¤±è´¥: %v", err)
failed++
} else {
r.log.Success("  âœ“ æˆåŠŸ")
removed++
}
}
}
if !found {
r.log.Info("  æœªæ‰¾åˆ°åŒ¹é…çš„åŒ…")
}
}
r.log.Info("æ¸…ç† WindowsApps æ®‹ç•™æ–‡ä»¶å¤¹...")
windowsAppsPath := filepath.Join(mountPath, "Program Files", "WindowsApps")
if utils.DirExists(windowsAppsPath) {
entries, err := os.ReadDir(windowsAppsPath)
if err == nil {
cleanedFolders := 0
for _, entry := range entries {
if !entry.IsDir() {
continue
}
folderName := entry.Name()
shouldRemove := false
for _, pattern := range extraPatterns {
cleanPattern := strings.Trim(pattern, "*")
if strings.Contains(strings.ToLower(folderName), strings.ToLower(cleanPattern)) {
shouldRemove = true
break
}
}
if shouldRemove {
folderPath := filepath.Join(windowsAppsPath, folderName)
r.log.Info("  åˆ é™¤æ–‡ä»¶å¤¹: %s", folderName)
if err := os.RemoveAll(folderPath); err != nil {
r.log.Warn("  âœ— åˆ é™¤å¤±è´¥: %v", err)
} else {
cleanedFolders++
}
}
}
if cleanedFolders > 0 {
r.log.Success("æ¸…ç†äº† %d ä¸ªæ®‹ç•™æ–‡ä»¶å¤¹", cleanedFolders)
}
}
}
r.log.Info("")
r.log.Success("æ‰©å±•åº”ç”¨ç§»é™¤å®Œæˆ: æˆåŠŸ %d, å¤±è´¥ %d", removed, failed)
return nil
}
func (r *NanoRemover) RemoveAggressivePackages(languageCode string) error {
mountPath := r.config.ScratchDir
r.log.Section("ç§»é™¤æ‰©å±•ç³»ç»ŸåŒ… (Nanoæ¨¡å¼)")
packagePatterns := []string{
"Microsoft-Windows-InternetExplorer-Optional-Package~", "Microsoft-Windows-MediaPlayer-Package~", "Microsoft-Windows-WordPad-FoD-Package~", "Microsoft-Windows-StepsRecorder-Package~", "Microsoft-Windows-MSPaint-FoD-Package~", "Microsoft-Windows-SnippingTool-FoD-Package~", "Microsoft-Windows-TabletPCMath-Package~", "Microsoft-Windows-Xps-Xps-Viewer-Opt-Package~", "Microsoft-Windows-PowerShell-ISE-FOD-Package~", "OpenSSH-Client-Package~", fmt.Sprintf("Microsoft-Windows-LanguageFeatures-Handwriting-%s-Package~", languageCode), fmt.Sprintf("Microsoft-Windows-LanguageFeatures-OCR-%s-Package~", languageCode), fmt.Sprintf("Microsoft-Windows-LanguageFeatures-Speech-%s-Package~", languageCode), fmt.Sprintf("Microsoft-Windows-LanguageFeatures-TextToSpeech-%s-Package~", languageCode), "*IME-ja-jp*", "*IME-ko-kr*", "*IME-zh-cn*", "*IME-zh-tw*", "Windows-Defender-Client-Package~", "Microsoft-Windows-Search-Engine-Client-Package~", "Microsoft-Windows-Kernel-LA57-FoD-Package~", "Microsoft-Windows-Hello-Face-Package~", "Microsoft-Windows-Hello-BioEnrollment-Package~", "Microsoft-Windows-BitLocker-DriveEncryption-FVE-Package~", "Microsoft-Windows-TPM-WMI-Provider-Package~", "Microsoft-Windows-Narrator-App-Package~", "Microsoft-Windows-Magnifier-App-Package~", "Microsoft-Windows-Printing-PMCPPC-FoD-Package~", "Microsoft-Windows-WebcamExperience-Package~", "Microsoft-Media-MPEG2-Decoder-Package~", "Microsoft-Windows-Wallpaper-Content-Extended-FoD-Package~", }
spinner := utils.NewSpinner("è·å–ç³»ç»ŸåŒ…åˆ—è¡¨...")
spinner.Start()
output, err := utils.RunCommand("dism", fmt.Sprintf("/image:%s", mountPath), "/Get-Packages", "/Format:Table")
spinner.Stop(err == nil)
if err != nil {
return fmt.Errorf("è·å–ç³»ç»ŸåŒ…åˆ—è¡¨å¤±è´¥: %w", err)
}
lines := strings.Split(output, "\n")
removed := 0
failed := 0
for i, pattern := range packagePatterns {
r.log.Info("[%d/%d] æ£€æŸ¥åŒ…æ¨¡å¼: %s", i+1, len(packagePatterns), utils.Colorize(pattern, utils.MikuYellow))
foundPackages := false
for _, line := range lines {
line = strings.TrimSpace(line)
if line == "" {
continue
}
matchFound := false
if strings.Contains(pattern, "*") {
cleanPattern := strings.Trim(pattern, "*")
if strings.Contains(strings.ToLower(line), strings.ToLower(cleanPattern)) {
matchFound = true
}
} else {
if strings.Contains(line, pattern) {
matchFound = true
}
}
if matchFound {
foundPackages = true
fields := strings.Fields(line)
if len(fields) > 0 {
pkgName := fields[0]
r.log.Info("  ç§»é™¤: %s", pkgName)
_, err := utils.RunCommand("dism", fmt.Sprintf("/image:%s", mountPath), "/Remove-Package", fmt.Sprintf("/PackageName:%s", pkgName))
if err != nil {
r.log.Warn("  âœ— å¤±è´¥: %v", err)
failed++
} else {
r.log.Success("  âœ“ æˆåŠŸ")
removed++
}
}
}
}
if !foundPackages {
r.log.Info("  æœªæ‰¾åˆ°åŒ¹é…çš„åŒ…")
}
}
r.log.Info("")
r.log.Success("ç³»ç»ŸåŒ…ç§»é™¤å®Œæˆ: æˆåŠŸ %d, å¤±è´¥ %d", removed, failed)
return nil
}
func (r *NanoRemover) RemoveNativeImages() error {
mountPath := r.config.ScratchDir
assemblyPath := filepath.Join(mountPath, "Windows", "assembly")
r.log.Section("ç§»é™¤é¢„ç¼–è¯‘ .NET ç¨‹åºé›†")
if !utils.DirExists(assemblyPath) {
r.log.Info("assembly ç›®å½•ä¸å­˜åœ¨ï¼Œè·³è¿‡")
return nil
}
entries, err := os.ReadDir(assemblyPath)
if err != nil {
return fmt.Errorf("è¯»å– assembly ç›®å½•å¤±è´¥: %w", err)
}
removed := 0
for _, entry := range entries {
if !entry.IsDir() {
continue
}
if strings.HasPrefix(entry.Name(), "NativeImages_") {
niPath := filepath.Join(assemblyPath, entry.Name())
r.log.Info("ç§»é™¤: %s", entry.Name())
if err := os.RemoveAll(niPath); err != nil {
r.log.Warn("  âœ— å¤±è´¥: %v", err)
} else {
r.log.Success("  âœ“ æˆåŠŸ")
removed++
}
}
}
if removed == 0 {
r.log.Info("æœªæ‰¾åˆ° NativeImages ç›®å½•")
} else {
r.log.Success("ç§»é™¤äº† %d ä¸ª Native Images ç›®å½•", removed)
}
return nil
}
func (r *NanoRemover) SlimDriverStore() error {
mountPath := r.config.ScratchDir
driverRepo := filepath.Join(mountPath, "Windows", "System32", "DriverStore", "FileRepository")
r.log.Section("ç²¾ç®€ DriverStore (ç§»é™¤éå¿…éœ€é©±åŠ¨)")
if !utils.DirExists(driverRepo) {
r.log.Warn("DriverStore ç›®å½•ä¸å­˜åœ¨: %s", driverRepo)
return nil
}
patternsToRemove := []string{
"prn*", "scan*", "mfd*", "wscsmd.inf*", "tapdrv*", "rdpbus.inf*", "tdibth.inf*", }
entries, err := os.ReadDir(driverRepo)
if err != nil {
return fmt.Errorf("è¯»å– DriverStore ç›®å½•å¤±è´¥: %w", err)
}
removed := 0
skipped := 0
for _, entry := range entries {
if !entry.IsDir() {
continue
}
driverName := entry.Name()
shouldRemove := false
for _, pattern := range patternsToRemove {
matched, _ := filepath.Match(pattern, strings.ToLower(driverName))
if matched {
shouldRemove = true
break
}
}
if shouldRemove {
driverPath := filepath.Join(driverRepo, driverName)
r.log.Info("ç§»é™¤é©±åŠ¨åŒ…: %s", driverName)
if err := os.RemoveAll(driverPath); err != nil {
r.log.Warn("  âœ— å¤±è´¥: %v", err)
skipped++
} else {
r.log.Success("  âœ“ æˆåŠŸ")
removed++
}
}
}
r.log.Info("")
r.log.Success("é©±åŠ¨å­˜å‚¨ç²¾ç®€å®Œæˆ: ç§»é™¤ %d ä¸ª, è·³è¿‡ %d ä¸ª", removed, skipped)
return nil
}
func (r *NanoRemover) SlimFonts() error {
mountPath := r.config.ScratchDir
fontsPath := filepath.Join(mountPath, "Windows", "Fonts")
r.log.Section("ç²¾ç®€ç³»ç»Ÿå­—ä½“ (åªä¿ç•™å¿…éœ€å­—ä½“)")
if !utils.DirExists(fontsPath) {
r.log.Warn("Fonts ç›®å½•ä¸å­˜åœ¨: %s", fontsPath)
return nil
}
keepPatterns := []string{
"segoe*", "tahoma*", "marlett.ttf", "8541oem.fon", "segui*", "consol*", "lucon*", "calibri*", "arial*", "times*", "cou*", "8*", }
removePatterns := []string{
"mingli*", "msjh*", "msyh*", "malgun*", "meiryo*", "yugoth*", "segoeuihistoric.ttf", }
entries, err := os.ReadDir(fontsPath)
if err != nil {
return fmt.Errorf("è¯»å– Fonts ç›®å½•å¤±è´¥: %w", err)
}
removed := 0
kept := 0
for _, entry := range entries {
if entry.IsDir() {
continue
}
fontName := entry.Name()
fontNameLower := strings.ToLower(fontName)
shouldKeep := false
shouldRemove := false
for _, pattern := range keepPatterns {
matched, _ := filepath.Match(pattern, fontNameLower)
if matched {
shouldKeep = true
break
}
}
for _, pattern := range removePatterns {
matched, _ := filepath.Match(pattern, fontNameLower)
if matched {
shouldRemove = true
break
}
}
if shouldRemove || !shouldKeep {
fontPath := filepath.Join(fontsPath, fontName)
if err := os.Remove(fontPath); err != nil {
} else {
removed++
}
} else {
kept++
}
}
r.log.Info("")
r.log.Success("å­—ä½“ç²¾ç®€å®Œæˆ: ç§»é™¤ %d ä¸ª, ä¿ç•™ %d ä¸ª", removed, kept)
return nil
}
func (r *NanoRemover) RemoveSystemFolders() error {
mountPath := r.config.ScratchDir
r.log.Section("ç§»é™¤éå¿…éœ€ç³»ç»Ÿæ–‡ä»¶å¤¹")
foldersToRemove := []struct {
path string
desc string
}{ {filepath.Join(mountPath, "Windows", "Speech", "Engines", "TTS"), "TTS è¯­éŸ³åˆæˆå¼•æ“"}, {filepath.Join(mountPath, "ProgramData", "Microsoft", "Windows Defender", "Definition Updates"), "Defender å®šä¹‰æ›´æ–°"}, {filepath.Join(mountPath, "Windows", "System32", "InputMethod", "CHS"), "ç®€ä½“ä¸­æ–‡è¾“å…¥æ³•"}, {filepath.Join(mountPath, "Windows", "System32", "InputMethod", "CHT"), "ç¹ä½“ä¸­æ–‡è¾“å…¥æ³•"}, {filepath.Join(mountPath, "Windows", "System32", "InputMethod", "JPN"), "æ—¥æ–‡è¾“å…¥æ³•"}, {filepath.Join(mountPath, "Windows", "System32", "InputMethod", "KOR"), "éŸ©æ–‡è¾“å…¥æ³•"}, {filepath.Join(mountPath, "Windows", "Temp"), "ä¸´æ—¶æ–‡ä»¶"}, {filepath.Join(mountPath, "Windows", "Web"), "Web å†…å®¹"}, {filepath.Join(mountPath, "Windows", "Help"), "å¸®åŠ©æ–‡ä»¶"}, {filepath.Join(mountPath, "Windows", "Cursors"), "å…‰æ ‡ä¸»é¢˜"}, }
removed := 0
skipped := 0
for i, folder := range foldersToRemove {
r.log.Info("[%d/%d] %s", i+1, len(foldersToRemove), folder.desc)
if !utils.DirExists(folder.path) {
r.log.Info("  ç›®å½•ä¸å­˜åœ¨ï¼Œè·³è¿‡")
skipped++
continue
}
if err := os.RemoveAll(folder.path); err != nil {
r.log.Warn("  âœ— å¤±è´¥: %v", err)
skipped++
} else {
r.log.Success("  âœ“ æˆåŠŸ")
removed++
}
}
r.log.Info("")
r.log.Success("ç³»ç»Ÿæ–‡ä»¶å¤¹ç§»é™¤å®Œæˆ: æˆåŠŸ %d, è·³è¿‡ %d", removed, skipped)
return nil
}
func (r *NanoRemover) RemoveSystemServices() error {
mountPath := r.config.ScratchDir
r.log.Section("ç§»é™¤éå¿…éœ€ç³»ç»ŸæœåŠ¡")
systemHive := filepath.Join(mountPath, "Windows", "System32", "config", "SYSTEM")
r.log.Info("åŠ è½½ SYSTEM æ³¨å†Œè¡¨...")
_, err := utils.RunCommand("reg", "load", "HKLM\\zSYSTEM", systemHive)
if err != nil {
return fmt.Errorf("åŠ è½½ SYSTEM hive å¤±è´¥: %w", err)
}
defer func() {
r.log.Info("å¸è½½ SYSTEM æ³¨å†Œè¡¨...")
utils.RunCommand("reg", "unload", "HKLM\\zSYSTEM")
}()
servicesToRemove := []string{
"Spooler", "PrintNotify", "Fax", "RemoteRegistry", "diagsvc", "WerSvc", "PcaSvc", "MapsBroker", "WalletService", "BthAvctpSvc", "BluetoothUserService", "wuauserv", "UsoSvc", "WaaSMedicSvc", }
removed := 0
failed := 0
for i, service := range servicesToRemove {
r.log.Info("[%d/%d] ç§»é™¤æœåŠ¡: %s", i+1, len(servicesToRemove), utils.Colorize(service, utils.MikuYellow))
servicePath := fmt.Sprintf("HKLM\\zSYSTEM\\ControlSet001\\Services\\%s", service)
_, err := utils.RunCommand("reg", "delete", servicePath, "/f")
if err != nil {
r.log.Info("  æœåŠ¡ä¸å­˜åœ¨æˆ–å·²ç§»é™¤")
failed++
} else {
r.log.Success("  âœ“ æˆåŠŸ")
removed++
}
}
r.log.Info("")
r.log.Success("æœåŠ¡ç§»é™¤å®Œæˆ: æˆåŠŸ %d, ä¸å­˜åœ¨ %d", removed, failed)
return nil
}
func (r *NanoRemover) CleanupWindowsAppsLeftovers(packagesToRemove []string) error {
mountPath := r.config.ScratchDir
windowsAppsPath := filepath.Join(mountPath, "Program Files", "WindowsApps")
r.log.Info("æ¸…ç† WindowsApps æ®‹ç•™æ–‡ä»¶å¤¹...")
if !utils.DirExists(windowsAppsPath) {
r.log.Info("WindowsApps ç›®å½•ä¸å­˜åœ¨ï¼Œè·³è¿‡")
return nil
}
entries, err := os.ReadDir(windowsAppsPath)
if err != nil {
return fmt.Errorf("è¯»å– WindowsApps ç›®å½•å¤±è´¥: %w", err)
}
cleaned := 0
for _, entry := range entries {
if !entry.IsDir() {
continue
}
folderName := entry.Name()
shouldRemove := false
for _, pkg := range packagesToRemove {
pkgBaseName := strings.Split(pkg, "_")[0]
if strings.Contains(folderName, pkgBaseName) {
shouldRemove = true
break
}
}
if shouldRemove {
folderPath := filepath.Join(windowsAppsPath, folderName)
r.log.Info("  åˆ é™¤æ®‹ç•™: %s", folderName)
if err := os.RemoveAll(folderPath); err != nil {
r.log.Warn("  âœ— å¤±è´¥: %v", err)
} else {
cleaned++
}
}
}
if cleaned > 0 {
r.log.Success("æ¸…ç†äº† %d ä¸ªæ®‹ç•™æ–‡ä»¶å¤¹", cleaned)
} else {
r.log.Info("æ²¡æœ‰å‘ç°æ®‹ç•™æ–‡ä»¶å¤¹")
}
return nil
}
```

### 21. internal\theme\applier.go

```go
package theme
import (
"fmt"
"os"
"path/filepath"
"strings"
"tiny11-builder/internal/config"
"tiny11-builder/internal/logger"
"tiny11-builder/internal/utils"
)
type Applier struct {
config *config.Config
log *logger.Logger
themeMgr *Manager
mountPath string
}
func NewApplier(cfg *config.Config, log *logger.Logger, themeMgr *Manager) *Applier {
return &Applier{
config: cfg, log: log, themeMgr: themeMgr, mountPath: cfg.ScratchDir, }
}
func (a *Applier) ApplyTheme(theme *Theme) error {
a.log.Section("åº”ç”¨ä¸»é¢˜: " + theme.Name)
successCount := 0
failCount := 0
if theme.Branding.Enabled {
a.log.Info("[1/7] åº”ç”¨å“ç‰Œä¿¡æ¯...")
if err := a.applyBranding(theme); err != nil {
a.log.Warn("  âœ— å“ç‰Œä¿¡æ¯åº”ç”¨å¤±è´¥: %v", err)
failCount++
} else {
a.log.Success("  âœ“ å“ç‰Œä¿¡æ¯å·²åº”ç”¨")
successCount++
}
} else {
a.log.Info("[1/7] è·³è¿‡å“ç‰Œä¿¡æ¯ (æœªå¯ç”¨)")
}
if theme.Wallpapers.Enabled {
a.log.Info("[2/7] åº”ç”¨å£çº¸...")
if err := a.applyWallpapers(theme); err != nil {
a.log.Warn("  âœ— å£çº¸åº”ç”¨å¤±è´¥: %v", err)
failCount++
} else {
a.log.Success("  âœ“ å£çº¸å·²åº”ç”¨")
successCount++
}
} else {
a.log.Info("[2/7] è·³è¿‡å£çº¸ (æœªå¯ç”¨)")
}
if theme.Colors.Enabled {
a.log.Info("[3/7] åº”ç”¨é…è‰²æ–¹æ¡ˆ...")
if err := a.applyColors(theme); err != nil {
a.log.Warn("  âœ— é…è‰²åº”ç”¨å¤±è´¥: %v", err)
failCount++
} else {
a.log.Success("  âœ“ é…è‰²æ–¹æ¡ˆå·²åº”ç”¨")
successCount++
}
} else {
a.log.Info("[3/7] è·³è¿‡é…è‰² (æœªå¯ç”¨)")
}
if theme.Images.Enabled {
a.log.Info("[4/7] åº”ç”¨å›¾æ ‡å’ŒLogo...")
if err := a.applyImages(theme); err != nil {
a.log.Warn("  âœ— å›¾æ ‡åº”ç”¨å¤±è´¥: %v", err)
failCount++
} else {
a.log.Success("  âœ“ å›¾æ ‡å’ŒLogoå·²åº”ç”¨")
successCount++
}
} else {
a.log.Info("[4/7] è·³è¿‡å›¾æ ‡ (æœªå¯ç”¨)")
}
if theme.Boot.Enabled {
a.log.Info("[5/7] åº”ç”¨å¯åŠ¨é…ç½®...")
if theme.Boot.CustomLogo {
if err := a.applyBootLogo(theme); err != nil {
a.log.Warn("  âœ— å¯åŠ¨Logoåº”ç”¨å¤±è´¥: %v", err)
failCount++
} else {
a.log.Success("  âœ“ å¯åŠ¨Logoå·²åº”ç”¨")
successCount++
}
} else {
a.log.Info("  è·³è¿‡è‡ªå®šä¹‰å¯åŠ¨Logo (æœªå¯ç”¨)")
}
} else {
a.log.Info("[5/7] è·³è¿‡å¯åŠ¨é…ç½® (æœªå¯ç”¨)")
}
if theme.Sounds.Enabled {
a.log.Info("[6/7] åº”ç”¨å£°éŸ³æ–¹æ¡ˆ...")
if err := a.applySounds(theme); err != nil {
a.log.Warn("  âœ— å£°éŸ³æ–¹æ¡ˆåº”ç”¨å¤±è´¥: %v", err)
failCount++
} else {
a.log.Success("  âœ“ å£°éŸ³æ–¹æ¡ˆå·²åº”ç”¨")
successCount++
}
} else {
a.log.Info("[6/7] è·³è¿‡å£°éŸ³æ–¹æ¡ˆ (æœªå¯ç”¨)")
}
if theme.Advanced.Enabled {
a.log.Info("[7/7] åº”ç”¨é«˜çº§è®¾ç½®...")
if err := a.applyAdvancedSettings(theme); err != nil {
a.log.Warn("  âœ— é«˜çº§è®¾ç½®åº”ç”¨å¤±è´¥: %v", err)
failCount++
} else {
a.log.Success("  âœ“ é«˜çº§è®¾ç½®å·²åº”ç”¨")
successCount++
}
} else {
a.log.Info("[7/7] è·³è¿‡é«˜çº§è®¾ç½® (æœªå¯ç”¨)")
}
a.log.Info("")
a.log.Success("ä¸»é¢˜åº”ç”¨å®Œæˆ: æˆåŠŸ %d, å¤±è´¥ %d", successCount, failCount)
return nil
}
func (a *Applier) applyBranding(theme *Theme) error {
branding, err := a.themeMgr.LoadBrandingData(theme)
if err != nil {
return fmt.Errorf("åŠ è½½å“ç‰Œæ•°æ®å¤±è´¥: %w", err)
}
applied := 0
if branding.ProductName != "" {
a.setRegistryValue(
"HKLM\\zSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", "ProductName", "REG_SZ", branding.ProductName, )
applied++
}
if branding.VersionInfo.DisplayVersion != "" {
a.setRegistryValue(
"HKLM\\zSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", "DisplayVersion", "REG_SZ", branding.VersionInfo.DisplayVersion, )
applied++
}
if branding.VersionInfo.BuildBranch != "" {
a.setRegistryValue(
"HKLM\\zSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", "BuildBranch", "REG_SZ", branding.VersionInfo.BuildBranch, )
applied++
}
if branding.VersionInfo.BuildLab != "" {
a.setRegistryValue(
"HKLM\\zSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", "BuildLab", "REG_SZ", branding.VersionInfo.BuildLab, )
applied++
}
if branding.SystemInfo.RegisteredOwner != "" {
a.setRegistryValue(
"HKLM\\zSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", "RegisteredOwner", "REG_SZ", branding.SystemInfo.RegisteredOwner, )
applied++
}
if branding.SystemInfo.RegisteredOrganization != "" {
a.setRegistryValue(
"HKLM\\zSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", "RegisteredOrganization", "REG_SZ", branding.SystemInfo.RegisteredOrganization, )
applied++
}
oemInfoPath := "HKLM\\zSOFTWARE\\Microsoft\\Windows\\CurrentVersion\\OEMInformation"
if branding.SystemInfo.Manufacturer != "" {
a.setRegistryValue(oemInfoPath, "Manufacturer", "REG_SZ", branding.SystemInfo.Manufacturer)
applied++
}
if branding.SystemInfo.Model != "" {
a.setRegistryValue(oemInfoPath, "Model", "REG_SZ", branding.SystemInfo.Model)
applied++
}
if branding.SystemInfo.SupportHours != "" {
a.setRegistryValue(oemInfoPath, "SupportHours", "REG_SZ", branding.SystemInfo.SupportHours)
applied++
}
if branding.SystemInfo.SupportPhone != "" {
a.setRegistryValue(oemInfoPath, "SupportPhone", "REG_SZ", branding.SystemInfo.SupportPhone)
applied++
}
if branding.SystemInfo.SupportURL != "" {
a.setRegistryValue(oemInfoPath, "SupportURL", "REG_SZ", branding.SystemInfo.SupportURL)
applied++
}
a.log.Info("  åº”ç”¨äº† %d é¡¹å“ç‰Œè®¾ç½®", applied)
return nil
}
func (a *Applier) applyWallpapers(theme *Theme) error {
applied := 0
wallpaperDir := filepath.Join(a.mountPath, "Windows", "Web", "Wallpaper", "Miku")
if err := os.MkdirAll(wallpaperDir, 0755); err != nil {
return fmt.Errorf("åˆ›å»ºå£çº¸ç›®å½•å¤±è´¥: %w", err)
}
if theme.Wallpapers.Desktop != "" {
srcDesktop := filepath.Join(theme.ThemePath, theme.Wallpapers.Desktop)
if !utils.FileExists(srcDesktop) {
a.log.Warn("  æ¡Œé¢å£çº¸æ–‡ä»¶ä¸å­˜åœ¨: %s", theme.Wallpapers.Desktop)
} else {
dstDesktop := filepath.Join(wallpaperDir, "desktop.jpg")
if err := utils.CopyFile(srcDesktop, dstDesktop); err != nil {
a.log.Warn("  å¤åˆ¶æ¡Œé¢å£çº¸å¤±è´¥: %v", err)
} else {
applied++
a.log.Info("  âœ“ æ¡Œé¢å£çº¸å·²å¤åˆ¶")
if theme.Wallpapers.SetAsDefault {
a.setRegistryValue(
"HKLM\\zNTUSER\\Control Panel\\Desktop", "Wallpaper", "REG_SZ", "%SystemRoot%\\Web\\Wallpaper\\Miku\\desktop.jpg", )
a.log.Info("  âœ“ å·²è®¾ç½®ä¸ºé»˜è®¤å£çº¸")
}
}
}
}
if theme.Wallpapers.Lockscreen != "" {
srcLock := filepath.Join(theme.ThemePath, theme.Wallpapers.Lockscreen)
if !utils.FileExists(srcLock) {
a.log.Warn("  é”å±å£çº¸æ–‡ä»¶ä¸å­˜åœ¨: %s", theme.Wallpapers.Lockscreen)
} else {
dstLock := filepath.Join(wallpaperDir, "lockscreen.jpg")
if err := utils.CopyFile(srcLock, dstLock); err != nil {
a.log.Warn("  å¤åˆ¶é”å±å£çº¸å¤±è´¥: %v", err)
} else {
applied++
a.log.Info("  âœ“ é”å±å£çº¸å·²å¤åˆ¶")
a.setRegistryValue(
"HKLM\\zSOFTWARE\\Policies\\Microsoft\\Windows\\Personalization", "LockScreenImage", "REG_SZ", "%SystemRoot%\\Web\\Wallpaper\\Miku\\lockscreen.jpg", )
}
}
}
if applied == 0 {
a.log.Info("  æœªè®¾ç½®ä»»ä½•å£çº¸è·¯å¾„")
}
return nil
}
func (a *Applier) applyColors(theme *Theme) error {
colors, err := a.themeMgr.LoadColorScheme(theme)
if err != nil {
return err
}
if !colors.Registry.ApplySystemWide {
a.log.Info("  é…è‰²æ–¹æ¡ˆè®¾ç½®ä¸ºä¸åº”ç”¨åˆ°ç³»ç»Ÿ")
return nil
}
applied := 0
if colors.Registry.AccentColor != "" {
a.setRegistryValue(
"HKLM\\zSOFTWARE\\Microsoft\\Windows\\DWM", "AccentColor", "REG_DWORD", colors.Registry.AccentColor, )
a.setRegistryValue(
"HKLM\\zNTUSER\\SOFTWARE\\Microsoft\\Windows\\DWM", "AccentColor", "REG_DWORD", colors.Registry.AccentColor, )
applied++
a.log.Info("  âœ“ å¼ºè°ƒè‰²: %s", colors.Registry.AccentColor)
}
if colors.Registry.StartColor != "" {
a.setRegistryValue(
"HKLM\\zNTUSER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize", "ColorPrevalence", "REG_DWORD", "1", )
applied++
a.log.Info("  âœ“ å¼€å§‹èœå•é…è‰²")
}
if theme.Colors.ApplyTransparency {
a.setRegistryValue(
"HKLM\\zNTUSER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize", "EnableTransparency", "REG_DWORD", "1", )
applied++
a.log.Info("  âœ“ é€æ˜æ•ˆæœå·²å¯ç”¨")
}
a.log.Info("  åº”ç”¨äº† %d é¡¹é…è‰²è®¾ç½®", applied)
return nil
}
func (a *Applier) applyImages(theme *Theme) error {
oemDir := filepath.Join(a.mountPath, "Windows", "System32", "oem")
if err := os.MkdirAll(oemDir, 0755); err != nil {
return fmt.Errorf("åˆ›å»ºOEMç›®å½•å¤±è´¥: %w", err)
}
applied := 0
if theme.Images.OEMLogo != "" {
srcLogo := filepath.Join(theme.ThemePath, theme.Images.OEMLogo)
dstLogo := filepath.Join(oemDir, "logo.bmp")
if utils.FileExists(srcLogo) {
if err := utils.CopyFile(srcLogo, dstLogo); err == nil {
a.setRegistryValue(
"HKLM\\zSOFTWARE\\Microsoft\\Windows\\CurrentVersion\\OEMInformation", "Logo", "REG_SZ", "%SystemRoot%\\System32\\oem\\logo.bmp", )
applied++
a.log.Info("  âœ“ OEM Logo")
}
} else {
a.log.Warn("  OEM Logoæ–‡ä»¶ä¸å­˜åœ¨: %s", theme.Images.OEMLogo)
}
}
if theme.Images.SystemLogo != "" {
srcSysLogo := filepath.Join(theme.ThemePath, theme.Images.SystemLogo)
dstSysLogo := filepath.Join(oemDir, "systemlogo.png")
if utils.FileExists(srcSysLogo) {
if utils.CopyFile(srcSysLogo, dstSysLogo) == nil {
applied++
a.log.Info("  âœ“ ç³»ç»ŸLogo")
}
} else {
a.log.Warn("  ç³»ç»ŸLogoæ–‡ä»¶ä¸å­˜åœ¨: %s", theme.Images.SystemLogo)
}
}
if theme.Images.UserTile != "" {
srcTile := filepath.Join(theme.ThemePath, theme.Images.UserTile)
userTileDir := filepath.Join(a.mountPath, "ProgramData", "Microsoft", "User Account Pictures")
os.MkdirAll(userTileDir, 0755)
dstTile := filepath.Join(userTileDir, "user.png")
if utils.FileExists(srcTile) {
if utils.CopyFile(srcTile, dstTile) == nil {
applied++
a.log.Info("  âœ“ ç”¨æˆ·å¤´åƒ")
}
} else {
a.log.Warn("  ç”¨æˆ·å¤´åƒæ–‡ä»¶ä¸å­˜åœ¨: %s", theme.Images.UserTile)
}
}
if theme.Images.BrandIcon != "" {
srcIcon := filepath.Join(theme.ThemePath, theme.Images.BrandIcon)
dstIcon := filepath.Join(oemDir, "brand.ico")
if utils.FileExists(srcIcon) {
if utils.CopyFile(srcIcon, dstIcon) == nil {
applied++
a.log.Info("  âœ“ å“ç‰Œå›¾æ ‡")
}
} else {
a.log.Warn("  å“ç‰Œå›¾æ ‡æ–‡ä»¶ä¸å­˜åœ¨: %s", theme.Images.BrandIcon)
}
}
a.log.Info("  åº”ç”¨äº† %d é¡¹å›¾æ ‡è®¾ç½®", applied)
return nil
}
func (a *Applier) applyBootLogo(theme *Theme) error {
if theme.Boot.LogoFile == "" {
a.log.Info("  æœªè®¾ç½®å¯åŠ¨Logoæ–‡ä»¶")
return nil
}
srcLogo := filepath.Join(theme.ThemePath, theme.Boot.LogoFile)
if !utils.FileExists(srcLogo) {
return fmt.Errorf("å¯åŠ¨Logoæ–‡ä»¶ä¸å­˜åœ¨: %s", srcLogo)
}
bootLogoDir := filepath.Join(a.mountPath, "Windows", "System32")
dstLogo := filepath.Join(bootLogoDir, "bootlogo.bmp")
if err := utils.CopyFile(srcLogo, dstLogo); err != nil {
return err
}
a.log.Info("  âœ“ å¯åŠ¨Logoå·²å¤åˆ¶")
if theme.Boot.BackgroundColor != "" {
color := a.parseColorToRGB(theme.Boot.BackgroundColor)
a.setRegistryValue(
"HKLM\\zSYSTEM\\ControlSet001\\Control\\BootControl", "BootProgressColor", "REG_DWORD", color, )
a.log.Info("  âœ“ å¯åŠ¨èƒŒæ™¯è‰²: %s", theme.Boot.BackgroundColor)
}
return nil
}
func (a *Applier) applySounds(theme *Theme) error {
soundsDir := filepath.Join(a.mountPath, "Windows", "Media", "Miku")
if err := os.MkdirAll(soundsDir, 0755); err != nil {
return fmt.Errorf("åˆ›å»ºå£°éŸ³ç›®å½•å¤±è´¥: %w", err)
}
soundMappings := map[string]struct {
src string
filename string
regKey string
name string
}{
"startup": {
src: theme.Sounds.Startup, filename: "startup.wav", regKey: "SystemStart", name: "å¯åŠ¨éŸ³", }, "shutdown": {
src: theme.Sounds.Shutdown, filename: "shutdown.wav", regKey: "SystemExit", name: "å…³æœºéŸ³", }, "logon": {
src: theme.Sounds.Logon, filename: "logon.wav", regKey: "WindowsLogon", name: "ç™»å½•éŸ³", }, }
applied := 0
for _, mapping := range soundMappings {
if mapping.src == "" {
continue
}
srcSound := filepath.Join(theme.ThemePath, mapping.src)
if !utils.FileExists(srcSound) {
a.log.Warn("  %sæ–‡ä»¶ä¸å­˜åœ¨: %s", mapping.name, mapping.src)
continue
}
dstSound := filepath.Join(soundsDir, mapping.filename)
if err := utils.CopyFile(srcSound, dstSound); err != nil {
a.log.Warn("  å¤åˆ¶%så¤±è´¥: %v", mapping.name, err)
continue
}
soundPath := fmt.Sprintf("%%SystemRoot%%\\Media\\Miku\\%s", mapping.filename)
a.setRegistryValue(
fmt.Sprintf("HKLM\\zNTUSER\\AppEvents\\Schemes\\Apps\\.Default\\%s\\.Current", mapping.regKey), "", "REG_SZ", soundPath, )
applied++
a.log.Info("  âœ“ %s", mapping.name)
}
a.log.Info("  åº”ç”¨äº† %d é¡¹å£°éŸ³è®¾ç½®", applied)
return nil
}
func (a *Applier) applyAdvancedSettings(theme *Theme) error {
applied := 0
settings := theme.Advanced.Settings
if settings.TaskbarTransparency {
if err := a.setRegistryValue(
"HKLM\\zNTUSER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize", "EnableTransparency", "REG_DWORD", "1", ); err == nil {
applied++
a.log.Info("  âœ“ ä»»åŠ¡æ é€æ˜åº¦")
}
}
if settings.RoundedCorners {
if err := a.setRegistryValue(
"HKLM\\zNTUSER\\SOFTWARE\\Microsoft\\Windows\\DWM", "UseRoundedCorners", "REG_DWORD", "1", ); err == nil {
applied++
a.log.Info("  âœ“ åœ†è§’çª—å£")
}
}
if settings.ShowFileExtensions {
if err := a.setRegistryValue(
"HKLM\\zNTUSER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced", "HideFileExt", "REG_DWORD", "0", ); err == nil {
applied++
a.log.Info("  âœ“ æ˜¾ç¤ºæ–‡ä»¶æ‰©å±•å")
}
}
if settings.ShowHiddenFiles {
if err := a.setRegistryValue(
"HKLM\\zNTUSER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced", "Hidden", "REG_DWORD", "1", ); err == nil {
applied++
a.log.Info("  âœ“ æ˜¾ç¤ºéšè—æ–‡ä»¶")
}
}
if settings.AccentColor != "" {
colorValue := a.parseColorToRGB(settings.AccentColor)
if err := a.setRegistryValue(
"HKLM\\zNTUSER\\SOFTWARE\\Microsoft\\Windows\\DWM", "ColorizationColor", "REG_DWORD", colorValue, ); err == nil {
applied++
a.log.Info("  âœ“ å¼ºè°ƒè‰²: %s", settings.AccentColor)
}
}
a.log.Info("  åº”ç”¨äº† %d é¡¹é«˜çº§è®¾ç½®", applied)
return nil
}
func (a *Applier) setRegistryValue(path, name, valueType, value string) error {
_, err := utils.RunCommand("reg", "add", path, "/v", name, "/t", valueType, "/d", value, "/f")
return err
}
func (a *Applier) parseColorToRGB(hexColor string) string {
hexColor = strings.TrimPrefix(hexColor, "#")
if strings.HasPrefix(hexColor, "0x") {
return hexColor
}
if len(hexColor) == 6 {
r := hexColor[0:2]
g := hexColor[2:4]
b := hexColor[4:6]
return "0x" + b + g + r
}
return "0x000000"
}
```

### 22. internal\theme\manager.go

```go
package theme
import (
"encoding/json"
"fmt"
"os"
"path/filepath"
"tiny11-builder/internal/config"
"tiny11-builder/internal/logger"
)
type Manager struct {
config *config.Config
log *logger.Logger
themesDir string
activeTheme *Theme
}
type Theme struct {
Name string `json:"name"`
Version string `json:"version"`
Author string `json:"author"`
Description string `json:"description"`
Enabled bool `json:"enabled"`
Branding BrandingConfig `json:"branding"`
Wallpapers WallpapersConfig `json:"wallpapers"`
Colors ColorsConfig `json:"colors"`
Images ImagesConfig `json:"images"`
Boot BootConfig `json:"boot"`
Sounds SoundsConfig `json:"sounds"`
Fonts FontsConfig `json:"fonts"`
Advanced AdvancedConfig `json:"advanced"`
ThemePath string `json:"-"`
}
type BrandingConfig struct {
Enabled bool `json:"enabled"`
ConfigFile string `json:"configFile"`
}
type WallpapersConfig struct {
Enabled bool `json:"enabled"`
Desktop string `json:"desktop"`
Lockscreen string `json:"lockscreen"`
SetAsDefault bool `json:"setAsDefault"`
}
type ColorsConfig struct {
Enabled bool `json:"enabled"`
ConfigFile string `json:"configFile"`
ApplyTransparency bool `json:"applyTransparency"`
}
type ImagesConfig struct {
Enabled bool `json:"enabled"`
SystemLogo string `json:"systemLogo"`
OEMLogo string `json:"oemLogo"`
UserTile string `json:"userTile"`
BrandIcon string `json:"brandIcon"`
}
type BootConfig struct {
Enabled bool `json:"enabled"`
CustomLogo bool `json:"customLogo"`
LogoFile string `json:"logoFile"`
BackgroundColor string `json:"backgroundColor"`
}
type SoundsConfig struct {
Enabled bool `json:"enabled"`
Startup string `json:"startup"`
Shutdown string `json:"shutdown"`
Logon string `json:"logon"`
}
type FontsConfig struct {
Enabled bool `json:"enabled"`
SystemFont string `json:"systemFont"`
}
type AdvancedConfig struct {
Enabled bool `json:"enabled"`
ModifyExplorer bool `json:"modifyExplorer"`
Settings AdvancedSettingsDetail `json:"settings"`
}
type AdvancedSettingsDetail struct {
AccentColor string `json:"accentColor"`
TaskbarTransparency bool `json:"taskbarTransparency"`
RoundedCorners bool `json:"roundedCorners"`
ShowFileExtensions bool `json:"showFileExtensions"`
ShowHiddenFiles bool `json:"showHiddenFiles"`
}
type BrandingData struct {
ProductName string `json:"productName"`
Edition struct {
MapOriginal bool `json:"mapOriginal"`
Mappings map[string]string `json:"mappings"`
} `json:"edition"`
SystemInfo struct {
RegisteredOwner string `json:"registeredOwner"`
RegisteredOrganization string `json:"registeredOrganization"`
Manufacturer string `json:"manufacturer"`
Model string `json:"model"`
SupportHours string `json:"supportHours"`
SupportPhone string `json:"supportPhone"`
SupportURL string `json:"supportURL"`
} `json:"systemInfo"`
VersionInfo struct {
DisplayVersion string `json:"displayVersion"`
BuildBranch string `json:"buildBranch"`
BuildLab string `json:"buildLab"`
CSDVersion string `json:"csdVersion"`
} `json:"versionInfo"`
OOBE struct {
OEMName string `json:"oemName"`
WelcomeTitle string `json:"welcomeTitle"`
WelcomeSubtitle string `json:"welcomeSubtitle"`
} `json:"oobe"`
}
type ColorScheme struct {
Name string `json:"name"`
Description string `json:"description"`
Colors struct {
Accent string `json:"accent"`
AccentLight string `json:"accentLight"`
AccentDark string `json:"accentDark"`
Secondary string `json:"secondary"`
SecondaryLight string `json:"secondaryLight"`
SecondaryDark string `json:"secondaryDark"`
Background string `json:"background"`
BackgroundDark string `json:"backgroundDark"`
Surface string `json:"surface"`
SurfaceDark string `json:"surfaceDark"`
Text string `json:"text"`
TextSecondary string `json:"textSecondary"`
TextDark string `json:"textDark"`
TextDarkSecondary string `json:"textDarkSecondary"`
Success string `json:"success"`
Warning string `json:"warning"`
Error string `json:"error"`
Info string `json:"info"`
} `json:"colors"`
Registry struct {
ApplySystemWide bool `json:"applySystemWide"`
AccentColor string `json:"accentColor"`
AccentColorMenu string `json:"accentColorMenu"`
StartColor string `json:"startColor"`
TaskbarColor string `json:"taskbarColor"`
TitleBarColor string `json:"titleBarColor"`
} `json:"registry"`
}
func NewManager(cfg *config.Config, log *logger.Logger) *Manager {
themesDir := filepath.Join(cfg.WorkDir, "themes")
return &Manager{
config: cfg, log: log, themesDir: themesDir, }
}
func (m *Manager) LoadTheme(themeName string) (*Theme, error) {
themePath := filepath.Join(m.themesDir, themeName)
themeFile := filepath.Join(themePath, "theme.json")
if _, err := os.Stat(themeFile); os.IsNotExist(err) {
return nil, fmt.Errorf("ä¸»é¢˜ä¸å­˜åœ¨: %s", themeName)
}
data, err := os.ReadFile(themeFile)
if err != nil {
return nil, fmt.Errorf("è¯»å–ä¸»é¢˜é…ç½®å¤±è´¥: %w", err)
}
var theme Theme
if err := json.Unmarshal(data, &theme); err != nil {
return nil, fmt.Errorf("è§£æä¸»é¢˜é…ç½®å¤±è´¥: %w", err)
}
theme.ThemePath = themePath
m.activeTheme = &theme
m.log.Success("åŠ è½½ä¸»é¢˜: %s v%s", theme.Name, theme.Version)
m.log.Info("  ä½œè€…: %s", theme.Author)
m.log.Info("  æè¿°: %s", theme.Description)
return &theme, nil
}
func (m *Manager) ListThemes() ([]string, error) {
if _, err := os.Stat(m.themesDir); os.IsNotExist(err) {
return nil, fmt.Errorf("ä¸»é¢˜ç›®å½•ä¸å­˜åœ¨: %s", m.themesDir)
}
entries, err := os.ReadDir(m.themesDir)
if err != nil {
return nil, err
}
var themes []string
for _, entry := range entries {
if entry.IsDir() {
themeFile := filepath.Join(m.themesDir, entry.Name(), "theme.json")
if _, err := os.Stat(themeFile); err == nil {
themes = append(themes, entry.Name())
}
}
}
return themes, nil
}
func (m *Manager) GetActiveTheme() *Theme {
return m.activeTheme
}
func (m *Manager) ValidateTheme(theme *Theme) []string {
var warnings []string
if theme.Wallpapers.Enabled {
if theme.Wallpapers.Desktop != "" {
desktop := filepath.Join(theme.ThemePath, theme.Wallpapers.Desktop)
if _, err := os.Stat(desktop); os.IsNotExist(err) {
warnings = append(warnings, fmt.Sprintf("æ¡Œé¢å£çº¸ä¸å­˜åœ¨: %s", theme.Wallpapers.Desktop))
}
}
if theme.Wallpapers.Lockscreen != "" {
lockscreen := filepath.Join(theme.ThemePath, theme.Wallpapers.Lockscreen)
if _, err := os.Stat(lockscreen); os.IsNotExist(err) {
warnings = append(warnings, fmt.Sprintf("é”å±å£çº¸ä¸å­˜åœ¨: %s", theme.Wallpapers.Lockscreen))
}
}
}
if theme.Images.Enabled {
images := map[string]string{
"ç³»ç»ŸLogo": theme.Images.SystemLogo, "OEM Logo": theme.Images.OEMLogo, "ç”¨æˆ·å¤´åƒ": theme.Images.UserTile, "å“ç‰Œå›¾æ ‡": theme.Images.BrandIcon, }
for name, path := range images {
if path != "" {
fullPath := filepath.Join(theme.ThemePath, path)
if _, err := os.Stat(fullPath); os.IsNotExist(err) {
warnings = append(warnings, fmt.Sprintf("%sä¸å­˜åœ¨: %s", name, path))
}
}
}
}
if theme.Boot.Enabled && theme.Boot.CustomLogo {
if theme.Boot.LogoFile != "" {
logoPath := filepath.Join(theme.ThemePath, theme.Boot.LogoFile)
if _, err := os.Stat(logoPath); os.IsNotExist(err) {
warnings = append(warnings, fmt.Sprintf("å¯åŠ¨Logoä¸å­˜åœ¨: %s", theme.Boot.LogoFile))
}
}
}
return warnings
}
func (m *Manager) LoadBrandingData(theme *Theme) (*BrandingData, error) {
if !theme.Branding.Enabled {
return nil, nil
}
brandingFile := filepath.Join(theme.ThemePath, theme.Branding.ConfigFile)
data, err := os.ReadFile(brandingFile)
if err != nil {
return nil, fmt.Errorf("è¯»å–å“ç‰Œé…ç½®å¤±è´¥: %w", err)
}
var branding BrandingData
if err := json.Unmarshal(data, &branding); err != nil {
return nil, fmt.Errorf("è§£æå“ç‰Œé…ç½®å¤±è´¥: %w", err)
}
return &branding, nil
}
func (m *Manager) LoadColorScheme(theme *Theme) (*ColorScheme, error) {
if !theme.Colors.Enabled {
return nil, nil
}
colorFile := filepath.Join(theme.ThemePath, theme.Colors.ConfigFile)
data, err := os.ReadFile(colorFile)
if err != nil {
return nil, fmt.Errorf("è¯»å–é…è‰²é…ç½®å¤±è´¥: %w", err)
}
var colors ColorScheme
if err := json.Unmarshal(data, &colors); err != nil {
return nil, fmt.Errorf("è§£æé…è‰²é…ç½®å¤±è´¥: %w", err)
}
return &colors, nil
}
```

### 23. internal\types\errors.go

```go
package types
import "fmt"
type ErrorCode int
const (
ErrCodeGeneral ErrorCode = iota + 1000
ErrCodePermission
ErrCodeNotFound
ErrCodeInvalidInput
ErrCodeDISM
ErrCodeDiskSpace
ErrCodeNetwork
)
type BuildError struct {
Code ErrorCode
Message string
Cause error
Context map[string]interface{}
}
func (e *BuildError) Error() string {
if e.Cause != nil {
return fmt.Sprintf("[%d] %s: %v", e.Code, e.Message, e.Cause)
}
return fmt.Sprintf("[%d] %s", e.Code, e.Message)
}
func NewError(code ErrorCode, message string, cause error) *BuildError {
return &BuildError{
Code: code, Message: message, Cause: cause, Context: make(map[string]interface{}), }
}
func (e *BuildError) WithContext(key string, value interface{}) *BuildError {
e.Context[key] = value
return e
}
```

### 24. internal\types\types.go

```go
package types
type BuildMode string
const (
ModeStandard BuildMode = "standard"
ModeCore BuildMode = "core"
ModeNano BuildMode = "nano"
)
type BuildRequest struct {
ISODrive string `json:"isoDrive"`
ScratchDrive string `json:"scratchDrive,omitempty"`
Mode BuildMode `json:"mode"`
Theme string `json:"theme"`
ImageIndex int `json:"imageIndex,omitempty"`
OutputISO string `json:"outputIso,omitempty"`
PreinstallApps []string `json:"preinstallApps,omitempty"`
UseESD bool `json:"useEsd,omitempty"`
Verbose bool `json:"verbose,omitempty"`
}
type BuildStatus struct {
Phase string `json:"phase"`
Progress float64 `json:"progress"`
Message string `json:"message"`
IsComplete bool `json:"isComplete"`
Error string `json:"error,omitempty"`
OutputISO string `json:"outputIso,omitempty"`
}
type BuildResponse struct {
Success bool `json:"success"`
Message string `json:"message"`
OutputISO string `json:"outputIso,omitempty"`
Error string `json:"error,omitempty"`
}
```

### 25. internal\utils\console.go

```go
package utils
import (
"fmt"
"syscall"
"unsafe"
"os"
"golang.org/x/sys/windows"
)
var (
kernel32 = syscall.NewLazyDLL("kernel32.dll")
procGetConsoleMode = kernel32.NewProc("GetConsoleMode")
procSetConsoleMode = kernel32.NewProc("SetConsoleMode")
procGetStdHandle = kernel32.NewProc("GetStdHandle")
procSetConsoleOutputCP = kernel32.NewProc("SetConsoleOutputCP")
procSetConsoleCP = kernel32.NewProc("SetConsoleCP")
)
const (
ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x0004
ENABLE_PROCESSED_OUTPUT = 0x0001
STD_OUTPUT_HANDLE = ^uintptr(10) + 1
CP_UTF8 = 65001
)
func InitConsole() error {
kernel32 := syscall.NewLazyDLL("kernel32.dll")
setConsoleCP := kernel32.NewProc("SetConsoleCP")
setConsoleOutputCP := kernel32.NewProc("SetConsoleOutputCP")
setConsoleCP.Call(uintptr(65001))
setConsoleOutputCP.Call(uintptr(65001))
os.Setenv("PYTHONIOENCODING", "utf-8")
os.Setenv("LANG", "en_US.UTF-8")
procSetConsoleOutputCP.Call(CP_UTF8)
procSetConsoleCP.Call(CP_UTF8)
handle, _, _ := procGetStdHandle.Call(STD_OUTPUT_HANDLE)
var mode uint32
procGetConsoleMode.Call(handle, uintptr(unsafe.Pointer(&mode)))
mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING | ENABLE_PROCESSED_OUTPUT
procSetConsoleMode.Call(handle, uintptr(mode))
return nil
}
func SetConsoleTitle(title string) {
titlePtr, _ := syscall.UTF16PtrFromString(title)
syscall.NewLazyDLL("kernel32.dll").NewProc("SetConsoleTitleW").Call(
uintptr(unsafe.Pointer(titlePtr)), )
}
func ClearScreen() {
cmd := windows.NewLazySystemDLL("kernel32.dll").NewProc("FillConsoleOutputCharacterW")
var csbi windows.ConsoleScreenBufferInfo
handle := windows.Handle(^uintptr(10) + 1)
windows.GetConsoleScreenBufferInfo(handle, &csbi)
var written uint32
size := uint32(csbi.Size.X) * uint32(csbi.Size.Y)
cmd.Call(
uintptr(handle), uintptr(' '), uintptr(size), 0, uintptr(unsafe.Pointer(&written)), )
windows.SetConsoleCursorPosition(handle, windows.Coord{X: 0, Y: 0})
}
func GetConsoleWidth() int {
var csbi windows.ConsoleScreenBufferInfo
handle := windows.Handle(^uintptr(10) + 1)
if err := windows.GetConsoleScreenBufferInfo(handle, &csbi); err != nil {
return 80
}
return int(csbi.Size.X)
}
const (
Reset = "\033[0m"
Bold = "\033[1m"
Dim = "\033[2m"
MikuCyan = "\033[38;2;57;197;187m"
MikuPink = "\033[38;2;255;105;180m"
MikuGreen = "\033[38;2;0;255;127m"
MikuYellow = "\033[38;2;255;215;0m"
MikuRed = "\033[38;2;255;107;107m"
MikuPurple = "\033[38;2;186;85;211m"
MikuWhite = "\033[38;2;255;255;255m"
MikuGray = "\033[38;2;128;128;128m"
BgMikuCyan = "\033[48;2;57;197;187m"
BgMikuPink = "\033[48;2;255;105;180m"
)
func Colorize(text, color string) string {
return color + text + Reset
}
func MikuBanner() {
banner := `
   â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ•— â–ˆâ–ˆâ•—
   â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘    â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•‘
   â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â•šâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•‘
   â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â•šâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘
   â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•       â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘
   â•šâ•â•     â•šâ•â•â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•        â•šâ•â•   â•šâ•â•â•šâ•â•  â•šâ•â•â•â•   â•šâ•â•    â•šâ•â• â•šâ•â•
`
fmt.Println(Colorize(banner, MikuCyan))
fmt.Println(Colorize("                    Windows 11 ç²¾ç®€é•œåƒæ„å»ºå·¥å…· - Miku Edition ğŸ€", MikuPink))
fmt.Println(Colorize("                         Powered by Go | Made with â™¥", MikuGray))
fmt.Println()
}
```

### 26. internal\utils\dism.go

```go
package utils
import (
"bytes"
"fmt"
"os/exec"
"syscall"
"golang.org/x/text/encoding/simplifiedchinese"
"golang.org/x/text/transform"
)
func RunDISMCommand(args ...string) (string, error) {
cmd := exec.Command("dism", args...)
cmd.SysProcAttr = &syscall.SysProcAttr{
HideWindow: true, }
var stdout, stderr bytes.Buffer
cmd.Stdout = &stdout
cmd.Stderr = &stderr
err := cmd.Run()
output := decodeOutput(stdout.Bytes())
if err != nil {
errMsg := decodeOutput(stderr.Bytes())
if errMsg != "" {
return output, fmt.Errorf("%w: %s", err, errMsg)
}
return output, err
}
return output, nil
}
func decodeOutput(data []byte) string {
str := string(data)
if containsGarbledText(str) {
decoder := simplifiedchinese.GBK.NewDecoder()
decoded, _, err := transform.Bytes(decoder, data)
if err == nil {
return string(decoded)
}
}
return str
}
func containsGarbledText(s string) bool {
for _, r := range s {
if r == 'ï¿½' {
return true
}
}
return false
}
```

### 27. internal\utils\encoding.go

```go
package utils
import (
"bytes"
"io"
"golang.org/x/text/encoding/simplifiedchinese"
"golang.org/x/text/transform"
)
func DecodeGBK(data []byte) (string, error) {
reader := transform.NewReader(bytes.NewReader(data), simplifiedchinese.GBK.NewDecoder())
decoded, err := io.ReadAll(reader)
if err != nil {
return string(data), err
}
return string(decoded), nil
}
func TryDecodeGBK(data []byte) string {
str := string(data)
if !containsGarbledChars(str) {
return str
}
decoded, err := DecodeGBK(data)
if err != nil {
return str
}
return decoded
}
func containsGarbledChars(s string) bool {
for _, r := range s {
if r == '\uFFFD' {
return true
}
if r > 127 && r < 256 {
return true
}
}
return false
}
```

### 28. internal\utils\filesystem.go

```go
package utils
import (
"fmt"
"io"
"net/http"
"os"
"path/filepath"
"runtime"
"sync"
"time"
"strings"
)
const (
MaxConcurrentCopy = 8
)
type CopyTask struct {
Src string
Dst string
Size int64
}
func CopyDirConcurrent(src, dst string, progress *ProgressBar) error {
var tasks []CopyTask
var totalSize int64
err := filepath.Walk(src, func(path string, info os.FileInfo, err error) error {
if err != nil {
return nil
}
relPath, _ := filepath.Rel(src, path)
targetPath := filepath.Join(dst, relPath)
if info.IsDir() {
return os.MkdirAll(targetPath, info.Mode())
}
tasks = append(tasks, CopyTask{
Src: path, Dst: targetPath, Size: info.Size(), })
totalSize += info.Size()
return nil
})
if err != nil {
return err
}
if progress == nil {
progress = NewProgressBar(totalSize, "å¤åˆ¶æ–‡ä»¶")
defer progress.Finish()
}
taskChan := make(chan CopyTask, len(tasks))
errChan := make(chan error, len(tasks))
var wg sync.WaitGroup
workers := MaxConcurrentCopy
if workers > runtime.NumCPU() {
workers = runtime.NumCPU()
}
for i := 0; i < workers; i++ {
wg.Add(1)
go func() {
defer wg.Done()
for task := range taskChan {
if err := copyFileOptimized(task.Src, task.Dst, task.Size, progress); err != nil {
select {
case errChan <- fmt.Errorf("å¤åˆ¶å¤±è´¥ %s: %w", task.Src, err):
default:
}
}
}
}()
}
for _, task := range tasks {
taskChan <- task
}
close(taskChan)
wg.Wait()
close(errChan)
if len(errChan) > 0 {
return <-errChan
}
runtime.GC()
return nil
}
func copyFileOptimized(src, dst string, fileSize int64, progress *ProgressBar) error {
sourceFile, err := os.Open(src)
if err != nil {
if progress != nil {
progress.Add(fileSize)
}
return nil
}
defer sourceFile.Close()
dstDir := filepath.Dir(dst)
if err := os.MkdirAll(dstDir, 0755); err != nil {
if progress != nil {
progress.Add(fileSize)
}
return err
}
destFile, err := os.Create(dst)
if err != nil {
if progress != nil {
progress.Add(fileSize)
}
return nil
}
defer destFile.Close()
var buf *[]byte
if fileSize < 1024*1024 {
buf = GetSmallBuffer()
defer PutSmallBuffer(buf)
} else {
buf = GetLargeBuffer()
defer PutLargeBuffer(buf)
}
for {
n, readErr := sourceFile.Read(*buf)
if n > 0 {
if _, writeErr := destFile.Write((*buf)[:n]); writeErr != nil {
return writeErr
}
if progress != nil {
progress.Add(int64(n))
}
}
if readErr == io.EOF {
break
}
if readErr != nil {
return readErr
}
}
return nil
}
func CopyFile(src, dst string) error {
sourceFile, err := os.Open(src)
if err != nil {
return fmt.Errorf("æ‰“å¼€æºæ–‡ä»¶å¤±è´¥: %w", err)
}
defer sourceFile.Close()
sourceInfo, err := sourceFile.Stat()
if err != nil {
return fmt.Errorf("è·å–æºæ–‡ä»¶ä¿¡æ¯å¤±è´¥: %w", err)
}
dstDir := filepath.Dir(dst)
if err := os.MkdirAll(dstDir, 0755); err != nil {
return fmt.Errorf("åˆ›å»ºç›®æ ‡ç›®å½•å¤±è´¥: %w", err)
}
destFile, err := os.Create(dst)
if err != nil {
return fmt.Errorf("åˆ›å»ºç›®æ ‡æ–‡ä»¶å¤±è´¥: %w", err)
}
defer destFile.Close()
buf := GetLargeBuffer()
defer PutLargeBuffer(buf)
_, err = io.CopyBuffer(destFile, sourceFile, *buf)
if err != nil {
return fmt.Errorf("å¤åˆ¶æ–‡ä»¶å†…å®¹å¤±è´¥: %w", err)
}
if err := destFile.Sync(); err != nil {
return fmt.Errorf("åŒæ­¥æ–‡ä»¶å¤±è´¥: %w", err)
}
if err := os.Chmod(dst, sourceInfo.Mode()); err != nil {
return fmt.Errorf("è®¾ç½®æ–‡ä»¶æƒé™å¤±è´¥: %w", err)
}
return nil
}
func CopyDir(src, dst string) error {
srcInfo, err := os.Stat(src)
if err != nil {
return fmt.Errorf("è·å–æºç›®å½•ä¿¡æ¯å¤±è´¥: %w", err)
}
if err := os.MkdirAll(dst, srcInfo.Mode()); err != nil {
return fmt.Errorf("åˆ›å»ºç›®æ ‡ç›®å½•å¤±è´¥: %w", err)
}
entries, err := os.ReadDir(src)
if err != nil {
return fmt.Errorf("è¯»å–ç›®å½•å†…å®¹å¤±è´¥: %w", err)
}
for _, entry := range entries {
srcPath := filepath.Join(src, entry.Name())
dstPath := filepath.Join(dst, entry.Name())
if entry.IsDir() {
if err := CopyDir(srcPath, dstPath); err != nil {
return err
}
} else {
if err := CopyFile(srcPath, dstPath); err != nil {
fmt.Printf("è­¦å‘Š: å¤åˆ¶æ–‡ä»¶å¤±è´¥ %s: %v\n", srcPath, err)
}
}
}
return nil
}
func DownloadFile(url, filepath string) error {
tmpFile := filepath + ".tmp"
maxRetries := 3
var lastErr error
for attempt := 1; attempt <= maxRetries; attempt++ {
if attempt > 1 {
time.Sleep(time.Duration(attempt) * time.Second)
}
err := downloadFileAttempt(url, tmpFile)
if err == nil {
if err := os.Rename(tmpFile, filepath); err != nil {
os.Remove(tmpFile)
return fmt.Errorf("é‡å‘½åä¸´æ—¶æ–‡ä»¶å¤±è´¥: %w", err)
}
return nil
}
lastErr = err
}
os.Remove(tmpFile)
return fmt.Errorf("ä¸‹è½½å¤±è´¥(å°è¯•%dæ¬¡): %w", maxRetries, lastErr)
}
func downloadFileAttempt(url, filepath string) error {
client := &http.Client{
Timeout: 60 * time.Second, }
resp, err := client.Get(url)
if err != nil {
return fmt.Errorf("HTTPè¯·æ±‚å¤±è´¥: %w", err)
}
defer resp.Body.Close()
if resp.StatusCode != http.StatusOK {
return fmt.Errorf("HTTPé”™è¯¯: %d %s", resp.StatusCode, resp.Status)
}
out, err := os.Create(filepath)
if err != nil {
return fmt.Errorf("åˆ›å»ºæ–‡ä»¶å¤±è´¥: %w", err)
}
defer out.Close()
buf := GetLargeBuffer()
defer PutLargeBuffer(buf)
_, err = io.CopyBuffer(out, resp.Body, *buf)
if err != nil {
return fmt.Errorf("å†™å…¥æ–‡ä»¶å¤±è´¥: %w", err)
}
if err := out.Sync(); err != nil {
return fmt.Errorf("åŒæ­¥æ–‡ä»¶å¤±è´¥: %w", err)
}
return nil
}
func FileExists(path string) bool {
info, err := os.Stat(path)
if os.IsNotExist(err) {
return false
}
if err != nil {
return false
}
return !info.IsDir()
}
func DirExists(path string) bool {
info, err := os.Stat(path)
if os.IsNotExist(err) {
return false
}
if err != nil {
return false
}
return info.IsDir()
}
func GetFileSize(path string) (int64, error) {
info, err := os.Stat(path)
if err != nil {
return 0, err
}
return info.Size(), nil
}
func GetDirSize(path string) (int64, error) {
var size int64
err := filepath.Walk(path, func(_ string, info os.FileInfo, err error) error {
if err != nil {
return nil
}
if !info.IsDir() {
size += info.Size()
}
return nil
})
return size, err
}
func CountFiles(path string) (int, error) {
count := 0
err := filepath.Walk(path, func(_ string, info os.FileInfo, err error) error {
if err != nil {
return nil
}
if !info.IsDir() {
count++
}
return nil
})
return count, err
}
func EnsureDir(path string) error {
if !DirExists(path) {
return os.MkdirAll(path, 0755)
}
return nil
}
func RemoveIfExists(path string) error {
if FileExists(path) || DirExists(path) {
return os.RemoveAll(path)
}
return nil
}
func FormatBytes(bytes int64) string {
const unit = 1024
if bytes < unit {
return fmt.Sprintf("%d B", bytes)
}
div, exp := int64(unit), 0
for n := bytes / unit; n >= unit; n /= unit {
div *= unit
exp++
}
units := []string{"KB", "MB", "GB", "TB", "PB", "EB"}
if exp >= len(units) {
exp = len(units) - 1
}
return fmt.Sprintf("%.2f %s", float64(bytes)/float64(div), units[exp])
}
func WriteFile(path string, content []byte) error {
dir := filepath.Dir(path)
if err := EnsureDir(dir); err != nil {
return fmt.Errorf("åˆ›å»ºç›®å½•å¤±è´¥: %w", err)
}
if err := os.WriteFile(path, content, 0644); err != nil {
return fmt.Errorf("å†™å…¥æ–‡ä»¶å¤±è´¥: %w", err)
}
return nil
}
func ReadFile(path string) ([]byte, error) {
data, err := os.ReadFile(path)
if err != nil {
return nil, fmt.Errorf("è¯»å–æ–‡ä»¶å¤±è´¥: %w", err)
}
return data, nil
}
func IsEmpty(path string) (bool, error) {
entries, err := os.ReadDir(path)
if err != nil {
return false, err
}
return len(entries) == 0, nil
}
func CleanDir(path string) error {
entries, err := os.ReadDir(path)
if err != nil {
return err
}
for _, entry := range entries {
fullPath := filepath.Join(path, entry.Name())
if err := os.RemoveAll(fullPath); err != nil {
return err
}
}
return nil
}
func GetTempDir() string {
return os.TempDir()
}
func CreateTempFile(pattern string) (*os.File, error) {
return os.CreateTemp("", pattern)
}
func CreateTempDir(pattern string) (string, error) {
return os.MkdirTemp("", pattern)
}
func SafeRemove(path string) {
os.RemoveAll(path)
}
func SafeRemoveAll(paths ...string) {
for _, path := range paths {
os.RemoveAll(path)
}
}
func CopyFileIfNotExists(src, dst string) error {
if FileExists(dst) {
return nil
}
return CopyFile(src, dst)
}
func MoveFile(src, dst string) error {
if err := EnsureDir(filepath.Dir(dst)); err != nil {
return err
}
if err := os.Rename(src, dst); err == nil {
return nil
}
if err := CopyFile(src, dst); err != nil {
return err
}
return os.Remove(src)
}
func TouchFile(path string) error {
if !FileExists(path) {
f, err := os.Create(path)
if err != nil {
return err
}
return f.Close()
}
now := time.Now()
return os.Chtimes(path, now, now)
}
func GetAbsPath(path string) (string, error) {
return filepath.Abs(path)
}
func IsSubPath(parent, child string) (bool, error) {
parentAbs, err := filepath.Abs(parent)
if err != nil {
return false, err
}
childAbs, err := filepath.Abs(child)
if err != nil {
return false, err
}
rel, err := filepath.Rel(parentAbs, childAbs)
if err != nil {
return false, err
}
return !strings.HasPrefix(rel, ".."), nil
}
func ListFiles(dir string) ([]string, error) {
var files []string
err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
if err != nil {
return nil
}
if !info.IsDir() {
files = append(files, path)
}
return nil
})
return files, err
}
func ListDirs(dir string) ([]string, error) {
var dirs []string
entries, err := os.ReadDir(dir)
if err != nil {
return nil, err
}
for _, entry := range entries {
if entry.IsDir() {
dirs = append(dirs, filepath.Join(dir, entry.Name()))
}
}
return dirs, nil
}
func GetFileExtension(path string) string {
return filepath.Ext(path)
}
func GetFileName(path string) string {
base := filepath.Base(path)
ext := filepath.Ext(base)
return base[:len(base)-len(ext)]
}
func JoinPath(elem ...string) string {
return filepath.Join(elem...)
}
func SplitPath(path string) (dir, file string) {
return filepath.Split(path)
}
```

### 29. internal\utils\pool.go

```go
package utils
import (
"sync"
)
var (
smallBufferPool = sync.Pool{
New: func() interface{} {
buf := make([]byte, 64*1024)
return &buf
}, }
largeBufferPool = sync.Pool{
New: func() interface{} {
buf := make([]byte, 1024*1024)
return &buf
}, }
)
func GetSmallBuffer() *[]byte {
return smallBufferPool.Get().(*[]byte)
}
func PutSmallBuffer(buf *[]byte) {
smallBufferPool.Put(buf)
}
func GetLargeBuffer() *[]byte {
return largeBufferPool.Get().(*[]byte)
}
func PutLargeBuffer(buf *[]byte) {
largeBufferPool.Put(buf)
}
```

### 30. internal\utils\process.go

```go
package utils
import (
"bytes"
"fmt"
"golang.org/x/sys/windows"
"os"
"os/exec"
"strings"
"syscall"
"time"
)
func RunCommand(name string, args ...string) (string, error) {
cmd := exec.Command(name, args...)
cmd.SysProcAttr = &syscall.SysProcAttr{
HideWindow: true}
var stdout, stderr bytes.Buffer
cmd.Stdout = &stdout
cmd.Stderr = &stderr
err := cmd.Run()
output := TryDecodeGBK(stdout.Bytes())
if err != nil {
errMsg := TryDecodeGBK(stderr.Bytes())
if errMsg != "" {
return output, fmt.Errorf("%w: %s", err, errMsg)
}
return output, err
}
return output, nil
}
func RunCommandWithOutput(name string, args ...string) error {
cmd := exec.Command(name, args...)
cmd.SysProcAttr = &syscall.SysProcAttr{
HideWindow: true}
cmd.Stdout = os.Stdout
cmd.Stderr = os.Stderr
return cmd.Run()
}
func Takeown(path string) error {
_, err := RunCommand("takeown", "/F", path)
if err != nil {
return fmt.Errorf("takeownå¤±è´¥: %w", err)
}
return nil
}
func TakeownRecursive(path string) error {
_, err := RunCommand("takeown", "/F", path, "/R")
if err != nil {
return fmt.Errorf("takeowné€’å½’å¤±è´¥: %w", err)
}
return nil
}
func GrantPermission(path string) error {
_, err := RunCommand("icacls", path, "/grant", "Administrators:(F)")
if err != nil {
return fmt.Errorf("icaclså¤±è´¥: %w", err)
}
return nil
}
func GrantPermissionRecursive(path string) error {
_, err := RunCommand("icacls", path, "/grant", "Administrators:(F)", "/T", "/C")
if err != nil {
return fmt.Errorf("icaclsé€’å½’å¤±è´¥: %w", err)
}
return nil
}
func ExtractField(output, field string) string {
lines := strings.Split(output, "\n")
prefix := field + " :"
for _, line := range lines {
trimmed := strings.TrimSpace(line)
if strings.HasPrefix(trimmed, prefix) {
value := strings.TrimPrefix(trimmed, prefix)
return strings.TrimSpace(value)
}
}
return ""
}
func ExtractLanguage(output string) string {
lines := strings.Split(output, "\n")
for _, line := range lines {
trimmed := strings.TrimSpace(line)
if strings.Contains(trimmed, "Default system UI language") {
parts := strings.Split(trimmed, ":")
if len(parts) >= 2 {
lang := strings.TrimSpace(parts[1])
if lang != "" {
return lang
}
}
}
}
for _, line := range lines {
trimmed := strings.TrimSpace(line)
if strings.Contains(trimmed, "Default language") {
parts := strings.Split(trimmed, ":")
if len(parts) >= 2 {
lang := strings.TrimSpace(parts[1])
if lang != "" {
return lang
}
}
}
}
return "en-US"
}
func KillProcess(name string) error {
cmd := exec.Command("taskkill", "/F", "/IM", name)
cmd.SysProcAttr = &syscall.SysProcAttr{HideWindow: true}
return cmd.Run()
}
func IsProcessRunning(name string) bool {
cmd := exec.Command("tasklist", "/FI", fmt.Sprintf("IMAGENAME eq %s", name))
cmd.SysProcAttr = &syscall.SysProcAttr{HideWindow: true}
output, err := cmd.Output()
if err != nil {
return false
}
return strings.Contains(string(output), name)
}
func GetSystemDrive() string {
systemDrive := os.Getenv("SystemDrive")
if systemDrive != "" && len(systemDrive) >= 2 && systemDrive[1] == ':' {
return systemDrive
}
systemRoot := os.Getenv("SystemRoot")
if len(systemRoot) >= 2 && systemRoot[1] == ':' {
return systemRoot[:2]
}
sysDir, err := windows.GetSystemDirectory()
if err == nil && len(sysDir) >= 2 && sysDir[1] == ':' {
return sysDir[:2]
}
winDir := os.Getenv("WINDIR")
if len(winDir) >= 2 && winDir[1] == ':' {
return winDir[:2]
}
return "C:"
}
func ValidateDriveLetter(drive string) bool {
if len(drive) != 2 {
return false
}
if drive[1] != ':' {
return false
}
letter := drive[0]
return (letter >= 'A' && letter <= 'Z') || (letter >= 'a' && letter <= 'z')
}
func Sleep(seconds int) {
time.Sleep(time.Duration(seconds) * time.Second)
}
```

---

> ğŸ“‹ **æç¤º**: è¿˜æœ‰ 13 ä¸ªæ–‡ä»¶æœªå±•ç¤ºï¼Œè¯·ç­‰å¾…å‘é€å®Œæ¯•åå†åˆ†æï¼
